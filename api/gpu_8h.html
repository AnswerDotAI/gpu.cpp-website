<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gpu.cpp: gpu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">gpu.cpp
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('gpu_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">gpu.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;array&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;future&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;webgpu/webgpu.h&quot;</code><br />
<code>#include &quot;numeric_types/half.h&quot;</code><br />
<code>#include &quot;<a class="el" href="logging_8h_source.html">utils/logging.h</a>&quot;</code><br />
</div>
<p><a href="gpu_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_array.html">gpu::Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of values on the GPU.  <a href="structgpu_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_shape.html">gpu::Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the shape of a tensor.  <a href="structgpu_1_1_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_tensor.html">gpu::Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a tensor on the GPU, which is a buffer of values with a shape.  <a href="structgpu_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_tensor_view.html">gpu::TensorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a non-owning view into a tensor specifying an offset and a subspan. This is useful for specifying a slice of a tensor on the GPU without copying the data.  <a href="structgpu_1_1_tensor_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_bindings.html">gpu::Bindings&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an ordered collection of WGPUBuffers (wrapped as tensors, non-overlapping views, or arrays) for the purpose of binding them to a kernel operation to make them accessible to the GPU kernel.  <a href="structgpu_1_1_bindings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_tensor_pool.html">gpu::TensorPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifetime of the tensors and freeing them when the pool is destroyed.  <a href="structgpu_1_1_tensor_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_kernel_code.html">gpu::KernelCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgpu_1_1_kernel_code.html" title="KernelCode is the representation of WGSL GPU code with template substitutions applied....">KernelCode</a> is the representation of WGSL GPU code with template substitutions applied. It is a type around the code string with additional metadata for workgroup size and precision since they are specified in the WGSL code. Additionally, label and entryPoint are used by <code><a class="el" href="namespacegpu.html#a62a564af334eff94a0fd4118c70e84f3" title="A factory function to create a kernel on the GPU. The kernel is created with the given WGSL code,...">createKernel()</a></code> to specify the label and entry point of the kernel.  <a href="structgpu_1_1_kernel_code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_callback_data.html">gpu::CallbackData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for on-done callback data for asynchronous operations sduch as kernel launching.  <a href="structgpu_1_1_callback_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_copy_data.html">gpu::CopyData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Staging buffer and callback data for copying data between the GPU and CPU.  <a href="structgpu_1_1_copy_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_kernel.html">gpu::Kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided into "consumed upon dispatch" (commandBuffer) and reusable ahead-of-time setup (all other members).  <a href="structgpu_1_1_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_kernel_pool.html">gpu::KernelPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of kernels to manage GPU resources. For simple use cases this is instantiated as a member in the <a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> struct although it's possible to have multiple resource pools of kernels in more complex scenarios.  <a href="structgpu_1_1_kernel_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_context.html">gpu::Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instance, adapter, device, and queue.  <a href="structgpu_1_1_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_no_param.html">gpu::NoParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgpu_1_1_no_param.html" title="NoParam is a no-op type used to indicate that a kernel does not have any parameters.">NoParam</a> is a no-op type used to indicate that a kernel does not have any parameters.  <a href="structgpu_1_1_no_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html">gpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7641c2218622a47af47216dc8b053fa9" id="r_a7641c2218622a47af47216dc8b053fa9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9">gpu::NumType</a> { <a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9a9caa1ff3c1c2f8b2906fa890614f323d">gpu::kf16</a>
, <a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">gpu::kf32</a>
 }</td></tr>
<tr class="separator:a7641c2218622a47af47216dc8b053fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad0a150a30d8cb17db98e18ad6df0dcea" id="r_ad0a150a30d8cb17db98e18ad6df0dcea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#ad0a150a30d8cb17db98e18ad6df0dcea">gpu::size</a> (const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:ad0a150a30d8cb17db98e18ad6df0dcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a tensor with the given shape, which is equal to the product of the dimensions.  <br /></td></tr>
<tr class="separator:ad0a150a30d8cb17db98e18ad6df0dcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800a846dae86c7d779a50139fac8224a" id="r_a800a846dae86c7d779a50139fac8224a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a800a846dae86c7d779a50139fac8224a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a800a846dae86c7d779a50139fac8224a">gpu::Bindings</a> (std::array&lt; <a class="el" href="structgpu_1_1_tensor.html">Tensor</a>, N &gt;) -&gt; Bindings&lt; N &gt;</td></tr>
<tr class="memdesc:a800a846dae86c7d779a50139fac8224a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for <a class="el" href="structgpu_1_1_bindings.html" title="Represents an ordered collection of WGPUBuffers (wrapped as tensors, non-overlapping views,...">Bindings</a>.  <br /></td></tr>
<tr class="separator:a800a846dae86c7d779a50139fac8224a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdffb34c646d3410de7e261caebdcd1" id="r_adfdffb34c646d3410de7e261caebdcd1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adfdffb34c646d3410de7e261caebdcd1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu.html#adfdffb34c646d3410de7e261caebdcd1">gpu::Bindings</a> (Args...) -&gt; Bindings&lt; sizeof...(Args)&gt;</td></tr>
<tr class="separator:adfdffb34c646d3410de7e261caebdcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4f458c8ea52a549339459aa46fafe0" id="r_aee4f458c8ea52a549339459aa46fafe0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#aee4f458c8ea52a549339459aa46fafe0">gpu::sizeBytes</a> (const <a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9">NumType</a> &amp;type)</td></tr>
<tr class="memdesc:aee4f458c8ea52a549339459aa46fafe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes of a number type.  <br /></td></tr>
<tr class="separator:aee4f458c8ea52a549339459aa46fafe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735cb8bbb44ccc41d38889342d5825ea" id="r_a735cb8bbb44ccc41d38889342d5825ea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a735cb8bbb44ccc41d38889342d5825ea">gpu::toString</a> (<a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9">NumType</a> type)</td></tr>
<tr class="memdesc:a735cb8bbb44ccc41d38889342d5825ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts NumType to string.  <br /></td></tr>
<tr class="separator:a735cb8bbb44ccc41d38889342d5825ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d124faa9f793d96e4e0e5531934ac9" id="r_ad9d124faa9f793d96e4e0e5531934ac9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#ad9d124faa9f793d96e4e0e5531934ac9">gpu::toString</a> (const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:ad9d124faa9f793d96e4e0e5531934ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> to string. The string formatting is meant to be slotted into WGSL code (hence no additional parentheses or brackets).  <br /></td></tr>
<tr class="separator:ad9d124faa9f793d96e4e0e5531934ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bec633630490d58392b1e4510dc5ef8" id="r_a5bec633630490d58392b1e4510dc5ef8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a5bec633630490d58392b1e4510dc5ef8">gpu::toString</a> (size_t value)</td></tr>
<tr class="memdesc:a5bec633630490d58392b1e4510dc5ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts size_t to string. Wraps std::to_string for consistency, instead of having to remember to switch between std::to_string and toString depending on the type.  <br /></td></tr>
<tr class="separator:a5bec633630490d58392b1e4510dc5ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58428241e500f69c95422e678ac2f0" id="r_a9f58428241e500f69c95422e678ac2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a9f58428241e500f69c95422e678ac2f0">gpu::replaceAll</a> (std::string &amp;str, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:a9f58428241e500f69c95422e678ac2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple in-place string replacement helper function for substituting placeholders in a WGSL string template.  <br /></td></tr>
<tr class="separator:a9f58428241e500f69c95422e678ac2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8054277aecd35b5d61ac5ce150aa6c22" id="r_a8054277aecd35b5d61ac5ce150aa6c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a8054277aecd35b5d61ac5ce150aa6c22">gpu::replaceAll</a> (std::string &amp;str, const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;reps)</td></tr>
<tr class="memdesc:a8054277aecd35b5d61ac5ce150aa6c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the string replacement helper function to replace multiple substrings in a string with multiple replacements.  <br /></td></tr>
<tr class="separator:a8054277aecd35b5d61ac5ce150aa6c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd91fae4ecbe9c19d23ac0e6f59efdaa" id="r_abd91fae4ecbe9c19d23ac0e6f59efdaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#abd91fae4ecbe9c19d23ac0e6f59efdaa">gpu::operator&lt;</a> (const <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;lhs, const <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;rhs)</td></tr>
<tr class="memdesc:abd91fae4ecbe9c19d23ac0e6f59efdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator implementation to make the <a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> type hashable.  <br /></td></tr>
<tr class="separator:abd91fae4ecbe9c19d23ac0e6f59efdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f54c3a36e4b4d7756995c7211bc212" id="r_a49f54c3a36e4b4d7756995c7211bc212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a49f54c3a36e4b4d7756995c7211bc212">gpu::createTensor</a> (<a class="el" href="structgpu_1_1_tensor_pool.html">TensorPool</a> &amp;pool, WGPUDevice &amp;device, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape, <a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9">NumType</a> dtype, WGPUBufferUsageFlags usage=WGPUBufferUsage_Storage|WGPUBufferUsage_CopyDst|WGPUBufferUsage_CopySrc)</td></tr>
<tr class="memdesc:a49f54c3a36e4b4d7756995c7211bc212"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> factory function to create a tensor (a <a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> type is simply an <a class="el" href="structgpu_1_1_array.html" title="Represents a buffer of values on the GPU.">Array</a> with an N-dimensional <a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> specification) on the GPU. The tensor is created with the given shape, data type, and usage flags, added to the <a class="el" href="structgpu_1_1_tensor_pool.html" title="Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifeti...">TensorPool</a>, and returned.  <br /></td></tr>
<tr class="separator:a49f54c3a36e4b4d7756995c7211bc212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e3c3540b76f01a7b991d0356e6f2f" id="r_a358e3c3540b76f01a7b991d0356e6f2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a358e3c3540b76f01a7b991d0356e6f2f">gpu::createTensor</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape, <a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9">NumType</a> dtype)</td></tr>
<tr class="memdesc:a358e3c3540b76f01a7b991d0356e6f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the tensor factory function to instantiate a tensor on the GPU with a given shape and data type.  <br /></td></tr>
<tr class="separator:a358e3c3540b76f01a7b991d0356e6f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b9e45c7c54c6e69e93101737cedcd7" id="r_a20b9e45c7c54c6e69e93101737cedcd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a20b9e45c7c54c6e69e93101737cedcd7">gpu::createTensor</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape, <a class="el" href="namespacegpu.html#a7641c2218622a47af47216dc8b053fa9">NumType</a> dtype, float *data)</td></tr>
<tr class="memdesc:a20b9e45c7c54c6e69e93101737cedcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the tensor factory function to instantiate a tensor on the GPU with a given shape, data type. Unlike the other overloads, this overload also takes initial data to populate the tensor with.  <br /></td></tr>
<tr class="separator:a20b9e45c7c54c6e69e93101737cedcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6ed2e0cf0953575f225df1ecac2970" id="r_a2b6ed2e0cf0953575f225df1ecac2970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a2b6ed2e0cf0953575f225df1ecac2970">gpu::FreeTensor</a> (<a class="el" href="structgpu_1_1_tensor_pool.html">TensorPool</a> &amp;pool, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> tensor)</td></tr>
<tr class="memdesc:a2b6ed2e0cf0953575f225df1ecac2970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a tensor resource and updates the tensor pool.  <br /></td></tr>
<tr class="separator:a2b6ed2e0cf0953575f225df1ecac2970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8bcb1dd85ad12c99d6f27ace6d891a" id="r_a3e8bcb1dd85ad12c99d6f27ace6d891a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a3e8bcb1dd85ad12c99d6f27ace6d891a">gpu::check</a> (bool condition, const char *message, const char *file=&quot;unkown&quot;, int line=-1)</td></tr>
<tr class="memdesc:a3e8bcb1dd85ad12c99d6f27ace6d891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a condition and logs an error message if the condition is false. In debug mode, it will also exit the program with an error code.  <br /></td></tr>
<tr class="separator:a3e8bcb1dd85ad12c99d6f27ace6d891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4931274b4522b102e4e98c5f056768" id="r_a1d4931274b4522b102e4e98c5f056768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a1d4931274b4522b102e4e98c5f056768">gpu::createContext</a> (const WGPUInstanceDescriptor &amp;desc={}, const WGPURequestAdapterOptions &amp;adapterOpts={}, WGPUDeviceDescriptor devDescriptor={})</td></tr>
<tr class="memdesc:a1d4931274b4522b102e4e98c5f056768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to create a GPU context, which aggregates WebGPU API handles to interact with the GPU including the instance, adapter, device, and queue.  <br /></td></tr>
<tr class="separator:a1d4931274b4522b102e4e98c5f056768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d750e74781cee97de3145d9949b777" id="r_ae2d750e74781cee97de3145d9949b777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#ae2d750e74781cee97de3145d9949b777">gpu::wait</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, std::future&lt; void &gt; &amp;future)</td></tr>
<tr class="separator:ae2d750e74781cee97de3145d9949b777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e645acd60386c08f5425ce2845856c0" id="r_a3e645acd60386c08f5425ce2845856c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a3e645acd60386c08f5425ce2845856c0">gpu::toCPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor, void *data, size_t bufferSize, <a class="el" href="structgpu_1_1_copy_data.html">CopyData</a> &amp;op)</td></tr>
<tr class="memdesc:a3e645acd60386c08f5425ce2845856c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a GPU buffer to CPU memory.  <br /></td></tr>
<tr class="separator:a3e645acd60386c08f5425ce2845856c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734d3d9f78813a05979a6b7fd76338ba" id="r_a734d3d9f78813a05979a6b7fd76338ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a734d3d9f78813a05979a6b7fd76338ba">gpu::toCPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor, void *data, size_t bufferSize)</td></tr>
<tr class="memdesc:a734d3d9f78813a05979a6b7fd76338ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the toCPU function to copy data from a GPU buffer to CPU but initializes a staging buffer and promise/future for the operation for you.  <br /></td></tr>
<tr class="separator:a734d3d9f78813a05979a6b7fd76338ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398921cf034bedbf09842257269b3d19" id="r_a398921cf034bedbf09842257269b3d19"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a398921cf034bedbf09842257269b3d19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a398921cf034bedbf09842257269b3d19">gpu::toCPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor, std::array&lt; float, N &gt; &amp;data)</td></tr>
<tr class="memdesc:a398921cf034bedbf09842257269b3d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the toCPU function to copy data from a GPU buffer to CPU memory for an array of floats instead of a pointer to a float buffer.  <br /></td></tr>
<tr class="separator:a398921cf034bedbf09842257269b3d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3f60f1a4282808c882b205d05c44ab" id="r_acb3f60f1a4282808c882b205d05c44ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#acb3f60f1a4282808c882b205d05c44ab">gpu::toGPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const void *data, WGPUBuffer buffer, size_t <a class="el" href="namespacegpu.html#ad0a150a30d8cb17db98e18ad6df0dcea">size</a>)</td></tr>
<tr class="memdesc:acb3f60f1a4282808c882b205d05c44ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from CPU memory to a GPU buffer. The toGPU overloads are effectively a convenience wrapper around the WebGPU API call wgpuQueueWriteBuffer.  <br /></td></tr>
<tr class="separator:acb3f60f1a4282808c882b205d05c44ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae6ec686b7fdf2f82ab515ea67b167" id="r_a2fae6ec686b7fdf2f82ab515ea67b167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a2fae6ec686b7fdf2f82ab515ea67b167">gpu::toGPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const float *data, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor)</td></tr>
<tr class="memdesc:a2fae6ec686b7fdf2f82ab515ea67b167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the toGPU function to copy data from CPU memory to a GPU taking a <a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance instead of a WGPUBuffer instance.  <br /></td></tr>
<tr class="separator:a2fae6ec686b7fdf2f82ab515ea67b167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1430a7956b8af8fe16e9694bd0217659" id="r_a1430a7956b8af8fe16e9694bd0217659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a1430a7956b8af8fe16e9694bd0217659">gpu::toGPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const half *data, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor)</td></tr>
<tr class="separator:a1430a7956b8af8fe16e9694bd0217659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0273ad1b353bd0cbde0460c87d929705" id="r_a0273ad1b353bd0cbde0460c87d929705"><td class="memTemplParams" colspan="2">template&lt;typename Params &gt; </td></tr>
<tr class="memitem:a0273ad1b353bd0cbde0460c87d929705"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a0273ad1b353bd0cbde0460c87d929705">gpu::toGPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, Params &amp;params, <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;op)</td></tr>
<tr class="separator:a0273ad1b353bd0cbde0460c87d929705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59323bc390c2a01dc473dcb72d03868" id="r_ac59323bc390c2a01dc473dcb72d03868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#ac59323bc390c2a01dc473dcb72d03868">gpu::resetCommandBuffer</a> (WGPUDevice &amp;device, <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;op)</td></tr>
<tr class="memdesc:ac59323bc390c2a01dc473dcb72d03868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the command buffer in preparation for a kernel dispatch. Since command buffers are consumed upon submission, this function is used both in the initial kernel creation and every time the kernel is to be reused for a dispatch.  <br /></td></tr>
<tr class="separator:ac59323bc390c2a01dc473dcb72d03868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae639cf27d731534ea42a77b63f928c88" id="r_ae639cf27d731534ea42a77b63f928c88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#ae639cf27d731534ea42a77b63f928c88">gpu::cdiv</a> (size_t n, size_t d)</td></tr>
<tr class="memdesc:ae639cf27d731534ea42a77b63f928c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ceiling division.  <br /></td></tr>
<tr class="separator:ae639cf27d731534ea42a77b63f928c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8678985df08ea0baed925266b5e43f" id="r_aea8678985df08ea0baed925266b5e43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_shape.html">Shape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#aea8678985df08ea0baed925266b5e43f">gpu::cdiv</a> (<a class="el" href="structgpu_1_1_shape.html">Shape</a> total, <a class="el" href="structgpu_1_1_shape.html">Shape</a> group)</td></tr>
<tr class="memdesc:aea8678985df08ea0baed925266b5e43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cdiv for shape specification. Mostly useful for evenly dividing total  <br /></td></tr>
<tr class="separator:aea8678985df08ea0baed925266b5e43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a564af334eff94a0fd4118c70e84f3" id="r_a62a564af334eff94a0fd4118c70e84f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a62a564af334eff94a0fd4118c70e84f3">gpu::createKernel</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_kernel_code.html">KernelCode</a> &amp;code, const <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> *dataBindings, size_t numTensors, const size_t *viewOffsets, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;nWorkgroups, const void *params=nullptr, size_t paramsSize=0)</td></tr>
<tr class="memdesc:a62a564af334eff94a0fd4118c70e84f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function to create a kernel on the GPU. The kernel is created with the given WGSL code, input tensors, output tensor, and optional parameters.  <br /></td></tr>
<tr class="separator:a62a564af334eff94a0fd4118c70e84f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b3f405db18bafc2e79f10b82f94f8b" id="r_aa1b3f405db18bafc2e79f10b82f94f8b"><td class="memTemplParams" colspan="2">template&lt;typename ParamsType  = NoParam, size_t numInputs&gt; </td></tr>
<tr class="memitem:aa1b3f405db18bafc2e79f10b82f94f8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu.html#aa1b3f405db18bafc2e79f10b82f94f8b">gpu::createKernel</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_kernel_code.html">KernelCode</a> &amp;code, const <a class="el" href="structgpu_1_1_bindings.html">Bindings</a>&lt; numInputs &gt; &amp;dataBindings, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;nWorkgroups, const ParamsType &amp;params=ParamsType{})</td></tr>
<tr class="memdesc:aa1b3f405db18bafc2e79f10b82f94f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which wraps the createKernel factory function to create a kernel on the GPU. This overload uses takes a static collection of input tensors instead of a pointer and a statically determined ParamsType instead of casting params to a void pointer.  <br /></td></tr>
<tr class="separator:aa1b3f405db18bafc2e79f10b82f94f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d0086bd70e16a57ea98d068b7ab226" id="r_ad9d0086bd70e16a57ea98d068b7ab226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpu.html#ad9d0086bd70e16a57ea98d068b7ab226">gpu::dispatchKernel</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;kernel, std::promise&lt; void &gt; &amp;promise)</td></tr>
<tr class="memdesc:ad9d0086bd70e16a57ea98d068b7ab226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously submits a kernel to the GPU queue for execution. It also sets up a callback to notify when the kernel has finished executing by setting the value of the promise in the kernel instance argument.  <br /></td></tr>
<tr class="separator:ad9d0086bd70e16a57ea98d068b7ab226"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9ff18d8b3b09f727e44a58cb443c2ddb" id="r_a9ff18d8b3b09f727e44a58cb443c2ddb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff18d8b3b09f727e44a58cb443c2ddb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegpu.html#a9ff18d8b3b09f727e44a58cb443c2ddb">gpu::IsNoParam</a> = std::is_same_v&lt;T, <a class="el" href="structgpu_1_1_no_param.html">NoParam</a>&gt;</td></tr>
<tr class="separator:a9ff18d8b3b09f727e44a58cb443c2ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="gpu_8h.html">gpu.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
