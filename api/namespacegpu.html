<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gpu.cpp: gpu Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">gpu.cpp
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacegpu.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">gpu Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a buffer of values on the GPU.  <a href="structgpu_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_bindings.html">Bindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an ordered collection of WGPUBuffers (wrapped as tensors, non-overlapping views, or arrays) for the purpose of binding them to a kernel operation to make them accessible to the GPU kernel.  <a href="structgpu_1_1_bindings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_callback_data_dyn.html">CallbackDataDyn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for on-done callback data for asynchronous operations sduch as kernel launching.  <a href="structgpu_1_1_callback_data_dyn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instance, adapter, device, and queue.  <a href="structgpu_1_1_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided into "consumed upon dispatch" (commandBuffer) and reusable ahead-of-time setup (all other members).  <a href="structgpu_1_1_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_kernel_code.html">KernelCode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgpu_1_1_kernel_code.html" title="KernelCode is the representation of WGSL GPU code with template substitutions applied....">KernelCode</a> is the representation of WGSL GPU code with template substitutions applied. It is a type around the code string with additional metadata for workgroup size and precision since they are specified in the WGSL code. Additionally, label and entryPoint are used by <code><a class="el" href="#a62a564af334eff94a0fd4118c70e84f3" title="A factory function to create a kernel on the GPU. The kernel is created with the given WGSL code,...">createKernel()</a></code> to specify the label and entry point of the kernel.  <a href="structgpu_1_1_kernel_code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_kernel_pool.html">KernelPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pool of kernels to manage GPU resources. For simple use cases this is instantiated as a member in the <a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> struct although it's possible to have multiple resource pools of kernels in more complex scenarios.  <a href="structgpu_1_1_kernel_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgpu_1_1_logger.html" title="Logger struct for logging messages. stream: The stream to log to. buffer: A buffer to store the forma...">Logger</a> struct for logging messages. stream: The stream to log to. buffer: A buffer to store the formatted message. level: The log level to log messages at.  <a href="structgpu_1_1_logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_no_param.html">NoParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgpu_1_1_no_param.html" title="NoParam is a no-op type used to indicate that a kernel does not have any parameters.">NoParam</a> is a no-op type used to indicate that a kernel does not have any parameters.  <a href="structgpu_1_1_no_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_shape.html">Shape</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the shape of a tensor.  <a href="structgpu_1_1_shape.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a tensor on the GPU, which is a buffer of values with a shape.  <a href="structgpu_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_tensor_pool.html">TensorPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifetime of the tensors and freeing them when the pool is destroyed.  <a href="structgpu_1_1_tensor_pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpu_1_1_tensor_view.html">TensorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a non-owning view into a tensor specifying an offset and a subspan. This is useful for specifying a slice of a tensor on the GPU without copying the data.  <a href="structgpu_1_1_tensor_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7641c2218622a47af47216dc8b053fa9" id="r_a7641c2218622a47af47216dc8b053fa9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a> { <a class="el" href="#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">kf32</a>
 }</td></tr>
<tr class="separator:a7641c2218622a47af47216dc8b053fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8387bde500e78abd34b817796e0ab156" id="r_a8387bde500e78abd34b817796e0ab156"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8387bde500e78abd34b817796e0ab156">LogLevel</a> { <a class="el" href="#a8387bde500e78abd34b817796e0ab156a56dc8400798e5d1c4812f2b96f484284">kError</a> = 0
, <a class="el" href="#a8387bde500e78abd34b817796e0ab156a73ec08472eddc3b9f92176e2a1537a14">kWarn</a> = 1
, <a class="el" href="#a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27">kInfo</a> = 2
, <a class="el" href="#a8387bde500e78abd34b817796e0ab156a92948dbbc0fe0cfbea020bbb04b58a04">kTrace</a> = 3
 }</td></tr>
<tr class="separator:a8387bde500e78abd34b817796e0ab156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad0a150a30d8cb17db98e18ad6df0dcea" id="r_ad0a150a30d8cb17db98e18ad6df0dcea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a> (const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:ad0a150a30d8cb17db98e18ad6df0dcea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in a tensor with the given shape, which is equal to the product of the dimensions.  <br /></td></tr>
<tr class="separator:ad0a150a30d8cb17db98e18ad6df0dcea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800a846dae86c7d779a50139fac8224a" id="r_a800a846dae86c7d779a50139fac8224a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a800a846dae86c7d779a50139fac8224a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a800a846dae86c7d779a50139fac8224a">Bindings</a> (std::array&lt; <a class="el" href="structgpu_1_1_tensor.html">Tensor</a>, N &gt;) -&gt; Bindings&lt; N &gt;</td></tr>
<tr class="memdesc:a800a846dae86c7d779a50139fac8224a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for <a class="el" href="structgpu_1_1_bindings.html" title="Represents an ordered collection of WGPUBuffers (wrapped as tensors, non-overlapping views,...">Bindings</a>.  <br /></td></tr>
<tr class="separator:a800a846dae86c7d779a50139fac8224a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdffb34c646d3410de7e261caebdcd1" id="r_adfdffb34c646d3410de7e261caebdcd1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adfdffb34c646d3410de7e261caebdcd1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfdffb34c646d3410de7e261caebdcd1">Bindings</a> (Args...) -&gt; Bindings&lt; sizeof...(Args)&gt;</td></tr>
<tr class="separator:adfdffb34c646d3410de7e261caebdcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735cb8bbb44ccc41d38889342d5825ea" id="r_a735cb8bbb44ccc41d38889342d5825ea"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a735cb8bbb44ccc41d38889342d5825ea">toString</a> (<a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a> type)</td></tr>
<tr class="memdesc:a735cb8bbb44ccc41d38889342d5825ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts NumType to string.  <br /></td></tr>
<tr class="separator:a735cb8bbb44ccc41d38889342d5825ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d124faa9f793d96e4e0e5531934ac9" id="r_ad9d124faa9f793d96e4e0e5531934ac9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9d124faa9f793d96e4e0e5531934ac9">toString</a> (const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape)</td></tr>
<tr class="memdesc:ad9d124faa9f793d96e4e0e5531934ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> to string. The string formatting is meant to be slotted into WGSL code (hence no additional parentheses or brackets).  <br /></td></tr>
<tr class="separator:ad9d124faa9f793d96e4e0e5531934ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bec633630490d58392b1e4510dc5ef8" id="r_a5bec633630490d58392b1e4510dc5ef8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bec633630490d58392b1e4510dc5ef8">toString</a> (size_t value)</td></tr>
<tr class="memdesc:a5bec633630490d58392b1e4510dc5ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts size_t to string. Wraps std::to_string for consistency, instead of having to remember to switch between std::to_string and toString depending on the type.  <br /></td></tr>
<tr class="separator:a5bec633630490d58392b1e4510dc5ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f58428241e500f69c95422e678ac2f0" id="r_a9f58428241e500f69c95422e678ac2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f58428241e500f69c95422e678ac2f0">replaceAll</a> (std::string &amp;str, const std::string &amp;from, const std::string &amp;to)</td></tr>
<tr class="memdesc:a9f58428241e500f69c95422e678ac2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple in-place string replacement helper function for substituting placeholders in a WGSL string template.  <br /></td></tr>
<tr class="separator:a9f58428241e500f69c95422e678ac2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8054277aecd35b5d61ac5ce150aa6c22" id="r_a8054277aecd35b5d61ac5ce150aa6c22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8054277aecd35b5d61ac5ce150aa6c22">replaceAll</a> (std::string &amp;str, const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;reps)</td></tr>
<tr class="memdesc:a8054277aecd35b5d61ac5ce150aa6c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the string replacement helper function to replace multiple substrings in a string with multiple replacements.  <br /></td></tr>
<tr class="separator:a8054277aecd35b5d61ac5ce150aa6c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd91fae4ecbe9c19d23ac0e6f59efdaa" id="r_abd91fae4ecbe9c19d23ac0e6f59efdaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd91fae4ecbe9c19d23ac0e6f59efdaa">operator&lt;</a> (const <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;lhs, const <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;rhs)</td></tr>
<tr class="memdesc:abd91fae4ecbe9c19d23ac0e6f59efdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator implementation to make the <a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> type hashable.  <br /></td></tr>
<tr class="separator:abd91fae4ecbe9c19d23ac0e6f59efdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f54c3a36e4b4d7756995c7211bc212" id="r_a49f54c3a36e4b4d7756995c7211bc212"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49f54c3a36e4b4d7756995c7211bc212">createTensor</a> (<a class="el" href="structgpu_1_1_tensor_pool.html">TensorPool</a> &amp;pool, WGPUDevice &amp;device, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape, <a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a> dtype, WGPUBufferUsageFlags usage=WGPUBufferUsage_Storage|WGPUBufferUsage_CopyDst|WGPUBufferUsage_CopySrc)</td></tr>
<tr class="memdesc:a49f54c3a36e4b4d7756995c7211bc212"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> factory function to create a tensor (a <a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> type is simply an <a class="el" href="structgpu_1_1_array.html" title="Represents a buffer of values on the GPU.">Array</a> with an N-dimensional <a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> specification) on the GPU. The tensor is created with the given shape, data type, and usage flags, added to the <a class="el" href="structgpu_1_1_tensor_pool.html" title="Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifeti...">TensorPool</a>, and returned.  <br /></td></tr>
<tr class="separator:a49f54c3a36e4b4d7756995c7211bc212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e3c3540b76f01a7b991d0356e6f2f" id="r_a358e3c3540b76f01a7b991d0356e6f2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a358e3c3540b76f01a7b991d0356e6f2f">createTensor</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape, <a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a> dtype)</td></tr>
<tr class="memdesc:a358e3c3540b76f01a7b991d0356e6f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the tensor factory function to instantiate a tensor on the GPU with a given shape and data type.  <br /></td></tr>
<tr class="separator:a358e3c3540b76f01a7b991d0356e6f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b9e45c7c54c6e69e93101737cedcd7" id="r_a20b9e45c7c54c6e69e93101737cedcd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b9e45c7c54c6e69e93101737cedcd7">createTensor</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;shape, <a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a> dtype, float *data)</td></tr>
<tr class="memdesc:a20b9e45c7c54c6e69e93101737cedcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the tensor factory function to instantiate a tensor on the GPU with a given shape, data type. Unlike the other overloads, this overload also takes initial data to populate the tensor with.  <br /></td></tr>
<tr class="separator:a20b9e45c7c54c6e69e93101737cedcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6ed2e0cf0953575f225df1ecac2970" id="r_a2b6ed2e0cf0953575f225df1ecac2970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b6ed2e0cf0953575f225df1ecac2970">FreeTensor</a> (<a class="el" href="structgpu_1_1_tensor_pool.html">TensorPool</a> &amp;pool, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> tensor)</td></tr>
<tr class="memdesc:a2b6ed2e0cf0953575f225df1ecac2970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a tensor resource and updates the tensor pool.  <br /></td></tr>
<tr class="separator:a2b6ed2e0cf0953575f225df1ecac2970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8bcb1dd85ad12c99d6f27ace6d891a" id="r_a3e8bcb1dd85ad12c99d6f27ace6d891a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e8bcb1dd85ad12c99d6f27ace6d891a">check</a> (bool condition, const char *message, const char *file=&quot;unkown&quot;, int line=-1)</td></tr>
<tr class="memdesc:a3e8bcb1dd85ad12c99d6f27ace6d891a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a condition and logs an error message if the condition is false. In debug mode, it will also exit the program with an error code.  <br /></td></tr>
<tr class="separator:a3e8bcb1dd85ad12c99d6f27ace6d891a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4931274b4522b102e4e98c5f056768" id="r_a1d4931274b4522b102e4e98c5f056768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_context.html">Context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d4931274b4522b102e4e98c5f056768">createContext</a> (const WGPUInstanceDescriptor &amp;desc={}, const WGPURequestAdapterOptions &amp;adapterOpts={}, WGPUDeviceDescriptor devDescriptor={})</td></tr>
<tr class="memdesc:a1d4931274b4522b102e4e98c5f056768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function to create a GPU context, which aggregates WebGPU API handles to interact with the GPU including the instance, adapter, device, and queue.  <br /></td></tr>
<tr class="separator:a1d4931274b4522b102e4e98c5f056768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d750e74781cee97de3145d9949b777" id="r_ae2d750e74781cee97de3145d9949b777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2d750e74781cee97de3145d9949b777">wait</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, std::future&lt; void &gt; &amp;future)</td></tr>
<tr class="separator:ae2d750e74781cee97de3145d9949b777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8512ee079905e5861ab90064caefc299" id="r_a8512ee079905e5861ab90064caefc299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8512ee079905e5861ab90064caefc299">toCPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor, float *data, size_t bufferSize)</td></tr>
<tr class="memdesc:a8512ee079905e5861ab90064caefc299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from a GPU buffer to CPU memory.  <br /></td></tr>
<tr class="separator:a8512ee079905e5861ab90064caefc299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398921cf034bedbf09842257269b3d19" id="r_a398921cf034bedbf09842257269b3d19"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a398921cf034bedbf09842257269b3d19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a398921cf034bedbf09842257269b3d19">toCPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor, std::array&lt; float, N &gt; &amp;data)</td></tr>
<tr class="memdesc:a398921cf034bedbf09842257269b3d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the toCPU function to copy data from a GPU buffer to CPU memory for an array of floats instead of a pointer to a float buffer.  <br /></td></tr>
<tr class="separator:a398921cf034bedbf09842257269b3d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3f60f1a4282808c882b205d05c44ab" id="r_acb3f60f1a4282808c882b205d05c44ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb3f60f1a4282808c882b205d05c44ab">toGPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const void *data, WGPUBuffer buffer, size_t <a class="el" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a>)</td></tr>
<tr class="memdesc:acb3f60f1a4282808c882b205d05c44ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from CPU memory to a GPU buffer. The toGPU overloads are effectively a convenience wrapper around the WebGPU API call wgpuQueueWriteBuffer.  <br /></td></tr>
<tr class="separator:acb3f60f1a4282808c882b205d05c44ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae6ec686b7fdf2f82ab515ea67b167" id="r_a2fae6ec686b7fdf2f82ab515ea67b167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fae6ec686b7fdf2f82ab515ea67b167">toGPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const float *data, <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;tensor)</td></tr>
<tr class="memdesc:a2fae6ec686b7fdf2f82ab515ea67b167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of the toGPU function to copy data from CPU memory to a GPU taking a <a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance instead of a WGPUBuffer instance.  <br /></td></tr>
<tr class="separator:a2fae6ec686b7fdf2f82ab515ea67b167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0273ad1b353bd0cbde0460c87d929705" id="r_a0273ad1b353bd0cbde0460c87d929705"><td class="memTemplParams" colspan="2">template&lt;typename Params &gt; </td></tr>
<tr class="memitem:a0273ad1b353bd0cbde0460c87d929705"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0273ad1b353bd0cbde0460c87d929705">toGPU</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, Params &amp;params, <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;op)</td></tr>
<tr class="separator:a0273ad1b353bd0cbde0460c87d929705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59323bc390c2a01dc473dcb72d03868" id="r_ac59323bc390c2a01dc473dcb72d03868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac59323bc390c2a01dc473dcb72d03868">resetCommandBuffer</a> (WGPUDevice &amp;device, <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;op)</td></tr>
<tr class="memdesc:ac59323bc390c2a01dc473dcb72d03868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the command buffer in preparation for a kernel dispatch. Since command buffers are consumed upon submission, this function is used both in the initial kernel creation and every time the kernel is to be reused for a dispatch.  <br /></td></tr>
<tr class="separator:ac59323bc390c2a01dc473dcb72d03868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae639cf27d731534ea42a77b63f928c88" id="r_ae639cf27d731534ea42a77b63f928c88"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae639cf27d731534ea42a77b63f928c88">cdiv</a> (size_t n, size_t d)</td></tr>
<tr class="memdesc:ae639cf27d731534ea42a77b63f928c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ceiling division.  <br /></td></tr>
<tr class="separator:ae639cf27d731534ea42a77b63f928c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8678985df08ea0baed925266b5e43f" id="r_aea8678985df08ea0baed925266b5e43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_shape.html">Shape</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea8678985df08ea0baed925266b5e43f">cdiv</a> (<a class="el" href="structgpu_1_1_shape.html">Shape</a> total, <a class="el" href="structgpu_1_1_shape.html">Shape</a> group)</td></tr>
<tr class="memdesc:aea8678985df08ea0baed925266b5e43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">cdiv for shape specification. Mostly useful for evenly dividing total  <br /></td></tr>
<tr class="separator:aea8678985df08ea0baed925266b5e43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a564af334eff94a0fd4118c70e84f3" id="r_a62a564af334eff94a0fd4118c70e84f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62a564af334eff94a0fd4118c70e84f3">createKernel</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_kernel_code.html">KernelCode</a> &amp;code, const <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> *dataBindings, size_t numTensors, const size_t *viewOffsets, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;nWorkgroups, const void *params=nullptr, size_t paramsSize=0)</td></tr>
<tr class="memdesc:a62a564af334eff94a0fd4118c70e84f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function to create a kernel on the GPU. The kernel is created with the given WGSL code, input tensors, output tensor, and optional parameters.  <br /></td></tr>
<tr class="separator:a62a564af334eff94a0fd4118c70e84f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b3f405db18bafc2e79f10b82f94f8b" id="r_aa1b3f405db18bafc2e79f10b82f94f8b"><td class="memTemplParams" colspan="2">template&lt;typename ParamsType  = NoParam, size_t numInputs&gt; </td></tr>
<tr class="memitem:aa1b3f405db18bafc2e79f10b82f94f8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa1b3f405db18bafc2e79f10b82f94f8b">createKernel</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, const <a class="el" href="structgpu_1_1_kernel_code.html">KernelCode</a> &amp;code, const <a class="el" href="structgpu_1_1_bindings.html">Bindings</a>&lt; numInputs &gt; &amp;dataBindings, const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;nWorkgroups, const ParamsType &amp;params=ParamsType{})</td></tr>
<tr class="memdesc:aa1b3f405db18bafc2e79f10b82f94f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which wraps the createKernel factory function to create a kernel on the GPU. This overload uses takes a static collection of input tensors instead of a pointer and a statically determined ParamsType instead of casting params to a void pointer.  <br /></td></tr>
<tr class="separator:aa1b3f405db18bafc2e79f10b82f94f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d0086bd70e16a57ea98d068b7ab226" id="r_ad9d0086bd70e16a57ea98d068b7ab226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9d0086bd70e16a57ea98d068b7ab226">dispatchKernel</a> (<a class="el" href="structgpu_1_1_context.html">Context</a> &amp;ctx, <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;kernel, std::promise&lt; void &gt; &amp;promise)</td></tr>
<tr class="memdesc:ad9d0086bd70e16a57ea98d068b7ab226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously submits a kernel to the GPU queue for execution. It also sets up a callback to notify when the kernel has finished executing by setting the value of the promise in the kernel instance argument.  <br /></td></tr>
<tr class="separator:ad9d0086bd70e16a57ea98d068b7ab226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a38bd3469ce5a2c7be8891f499bb24" id="r_a70a38bd3469ce5a2c7be8891f499bb24"><td class="memTemplParams" colspan="2">template&lt;typename numtype &gt; </td></tr>
<tr class="memitem:a70a38bd3469ce5a2c7be8891f499bb24"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70a38bd3469ce5a2c7be8891f499bb24">show</a> (const numtype *a, size_t rows, size_t cols, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a70a38bd3469ce5a2c7be8891f499bb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show a 2D array as a string, base implementation.  <br /></td></tr>
<tr class="separator:a70a38bd3469ce5a2c7be8891f499bb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7b41f8fbb4b127d4c43b494bf9d950" id="r_a6a7b41f8fbb4b127d4c43b494bf9d950"><td class="memTemplParams" colspan="2">template&lt;typename numtype , size_t rows, size_t cols&gt; </td></tr>
<tr class="memitem:a6a7b41f8fbb4b127d4c43b494bf9d950"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6a7b41f8fbb4b127d4c43b494bf9d950">show</a> (const std::array&lt; numtype, rows *cols &gt; &amp;a, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a6a7b41f8fbb4b127d4c43b494bf9d950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="#a70a38bd3469ce5a2c7be8891f499bb24" title="Show a 2D array as a string, base implementation.">show()</a></code> for std::array.  <br /></td></tr>
<tr class="separator:a6a7b41f8fbb4b127d4c43b494bf9d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558085d4f4bdbc85d9d894c05e8c79e0" id="r_a558085d4f4bdbc85d9d894c05e8c79e0"><td class="memTemplParams" colspan="2">template&lt;size_t rows, size_t cols&gt; </td></tr>
<tr class="memitem:a558085d4f4bdbc85d9d894c05e8c79e0"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a558085d4f4bdbc85d9d894c05e8c79e0">show</a> (const std::array&lt; float, rows *cols &gt; &amp;a, const std::string &amp;name=&quot;&quot;)</td></tr>
<tr class="memdesc:a558085d4f4bdbc85d9d894c05e8c79e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="#a70a38bd3469ce5a2c7be8891f499bb24" title="Show a 2D array as a string, base implementation.">show()</a></code> for float std::array.  <br /></td></tr>
<tr class="separator:a558085d4f4bdbc85d9d894c05e8c79e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dfc7beab528e65823ed28d9095149db" id="r_a4dfc7beab528e65823ed28d9095149db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4dfc7beab528e65823ed28d9095149db">range</a> (float *input, size_t N, float start=0.0, float step=1.0)</td></tr>
<tr class="memdesc:a4dfc7beab528e65823ed28d9095149db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the array with a range of values. This is mostly for testing purposes.  <br /></td></tr>
<tr class="separator:a4dfc7beab528e65823ed28d9095149db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3990d3a9153396be1f532601bb8d1da0" id="r_a3990d3a9153396be1f532601bb8d1da0"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a3990d3a9153396be1f532601bb8d1da0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3990d3a9153396be1f532601bb8d1da0">range</a> (std::array&lt; float, N &gt; &amp;input, float start=0.0, float step=1.0)</td></tr>
<tr class="memdesc:a3990d3a9153396be1f532601bb8d1da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="#a4dfc7beab528e65823ed28d9095149db" title="Populate the array with a range of values. This is mostly for testing purposes.">range()</a></code> for std::array.  <br /></td></tr>
<tr class="separator:a3990d3a9153396be1f532601bb8d1da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958ba3c82efaee6749be9f5b828027db" id="r_a958ba3c82efaee6749be9f5b828027db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a958ba3c82efaee6749be9f5b828027db">randint</a> (float *a, size_t N, std::mt19937 &amp;gen, int min=-1, int max=1)</td></tr>
<tr class="memdesc:a958ba3c82efaee6749be9f5b828027db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the array with random integers.  <br /></td></tr>
<tr class="separator:a958ba3c82efaee6749be9f5b828027db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331ec9b4ea7d787eae6994c5ae7d32d2" id="r_a331ec9b4ea7d787eae6994c5ae7d32d2"><td class="memTemplParams" colspan="2">template&lt;typename numtype , size_t size&gt; </td></tr>
<tr class="memitem:a331ec9b4ea7d787eae6994c5ae7d32d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a331ec9b4ea7d787eae6994c5ae7d32d2">randint</a> (std::array&lt; numtype, <a class="el" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a> &gt; &amp;a, std::mt19937 &amp;gen, int min=-1, int max=1)</td></tr>
<tr class="memdesc:a331ec9b4ea7d787eae6994c5ae7d32d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="#a958ba3c82efaee6749be9f5b828027db" title="Populate the array with random integers.">randint()</a></code> for std::array.  <br /></td></tr>
<tr class="separator:a331ec9b4ea7d787eae6994c5ae7d32d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64154e5de68ac36383b7bfb8a5dfc57f" id="r_a64154e5de68ac36383b7bfb8a5dfc57f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64154e5de68ac36383b7bfb8a5dfc57f">randn</a> (float *a, size_t N, std::mt19937 &amp;gen, float mean=0.0, float std=1.0)</td></tr>
<tr class="memdesc:a64154e5de68ac36383b7bfb8a5dfc57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the array with random floats, generated from a Gaussian distribution.  <br /></td></tr>
<tr class="separator:a64154e5de68ac36383b7bfb8a5dfc57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d0e6da05536cf06dd497542bff379" id="r_a4d0d0e6da05536cf06dd497542bff379"><td class="memTemplParams" colspan="2">template&lt;size_t size&gt; </td></tr>
<tr class="memitem:a4d0d0e6da05536cf06dd497542bff379"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4d0d0e6da05536cf06dd497542bff379">randn</a> (std::array&lt; float, <a class="el" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a> &gt; &amp;a, std::mt19937 &amp;gen, float mean=0.0, float std=1.0)</td></tr>
<tr class="memdesc:a4d0d0e6da05536cf06dd497542bff379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="#a64154e5de68ac36383b7bfb8a5dfc57f" title="Populate the array with random floats, generated from a Gaussian distribution.">randn()</a></code> for std::array.  <br /></td></tr>
<tr class="separator:a4d0d0e6da05536cf06dd497542bff379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51976a8056f4e718ae36e5c256f58fc3" id="r_a51976a8056f4e718ae36e5c256f58fc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51976a8056f4e718ae36e5c256f58fc3">eye</a> (float *a, size_t N)</td></tr>
<tr class="memdesc:a51976a8056f4e718ae36e5c256f58fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a square matrix with the identity matrix.  <br /></td></tr>
<tr class="separator:a51976a8056f4e718ae36e5c256f58fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841ef6a84098e4202bfd50e08e33164c" id="r_a841ef6a84098e4202bfd50e08e33164c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a841ef6a84098e4202bfd50e08e33164c">transpose</a> (float *input, float *output, size_t M, size_t N)</td></tr>
<tr class="memdesc:a841ef6a84098e4202bfd50e08e33164c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a matrix.  <br /></td></tr>
<tr class="separator:a841ef6a84098e4202bfd50e08e33164c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43fe29a6e3cdc14168666a7abfc3196" id="r_ae43fe29a6e3cdc14168666a7abfc3196"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae43fe29a6e3cdc14168666a7abfc3196">flip</a> (float *a, size_t R, size_t C, bool horizontal=true)</td></tr>
<tr class="memdesc:ae43fe29a6e3cdc14168666a7abfc3196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip a matrix horizontally or vertically.  <br /></td></tr>
<tr class="separator:ae43fe29a6e3cdc14168666a7abfc3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f10f29c89d81fc5358ea9485ee6fa3" id="r_a69f10f29c89d81fc5358ea9485ee6fa3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69f10f29c89d81fc5358ea9485ee6fa3">isclose</a> (float *a, float *b, size_t n, float tol=1e-3)</td></tr>
<tr class="memdesc:a69f10f29c89d81fc5358ea9485ee6fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the values of two arrays are close to each other.  <br /></td></tr>
<tr class="separator:a69f10f29c89d81fc5358ea9485ee6fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508fff3f15882a37b1c0bd0341296176" id="r_a508fff3f15882a37b1c0bd0341296176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a> (<a class="el" href="structgpu_1_1_logger.html">Logger</a> &amp;logger, int level, const char *message,...)</td></tr>
<tr class="memdesc:a508fff3f15882a37b1c0bd0341296176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log a message to the logger. If NDEBUG is defined in a source or as a compiler flag, this is a no-op.  <br /></td></tr>
<tr class="separator:a508fff3f15882a37b1c0bd0341296176"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa260b4aa723e3754e338952a00a00fa5" id="r_aa260b4aa723e3754e338952a00a00fa5"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa260b4aa723e3754e338952a00a00fa5">kDebug</a> = true</td></tr>
<tr class="separator:aa260b4aa723e3754e338952a00a00fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff18d8b3b09f727e44a58cb443c2ddb" id="r_a9ff18d8b3b09f727e44a58cb443c2ddb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ff18d8b3b09f727e44a58cb443c2ddb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9ff18d8b3b09f727e44a58cb443c2ddb">IsNoParam</a> = std::is_same_v&lt;T, <a class="el" href="structgpu_1_1_no_param.html">NoParam</a>&gt;</td></tr>
<tr class="separator:a9ff18d8b3b09f727e44a58cb443c2ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add001dc6cf01bdd72293694791d5d1bc" id="r_add001dc6cf01bdd72293694791d5d1bc"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add001dc6cf01bdd72293694791d5d1bc">kShowMaxRows</a> = 8</td></tr>
<tr class="separator:add001dc6cf01bdd72293694791d5d1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba79867fea95e4073373d7618094a9cd" id="r_aba79867fea95e4073373d7618094a9cd"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba79867fea95e4073373d7618094a9cd">kShowMaxCols</a> = 8</td></tr>
<tr class="separator:aba79867fea95e4073373d7618094a9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d3f2326d04b410a85cbd7b3ac2b876" id="r_ae1d3f2326d04b410a85cbd7b3ac2b876"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1d3f2326d04b410a85cbd7b3ac2b876">kLevelStr</a> [] = {&quot;error&quot;, &quot;warn&quot;, &quot;info&quot;, &quot;trace&quot;}</td></tr>
<tr class="separator:ae1d3f2326d04b410a85cbd7b3ac2b876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0188200bb20637971454432ffdb2e3ab" id="r_a0188200bb20637971454432ffdb2e3ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structgpu_1_1_logger.html">Logger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0188200bb20637971454432ffdb2e3ab">kDefLog</a> = {stdout, &quot;&quot;, <a class="el" href="#a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27">kInfo</a>}</td></tr>
<tr class="memdesc:a0188200bb20637971454432ffdb2e3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default logger for logging messages to stdout at the info level. Output stream and logging level for the default logger can be globally changed on a per-program basis.  <br /></td></tr>
<tr class="separator:a0188200bb20637971454432ffdb2e3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8387bde500e78abd34b817796e0ab156" name="a8387bde500e78abd34b817796e0ab156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8387bde500e78abd34b817796e0ab156">&#9670;&#160;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a8387bde500e78abd34b817796e0ab156">gpu::LogLevel</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8387bde500e78abd34b817796e0ab156a56dc8400798e5d1c4812f2b96f484284" name="a8387bde500e78abd34b817796e0ab156a56dc8400798e5d1c4812f2b96f484284"></a>kError&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8387bde500e78abd34b817796e0ab156a73ec08472eddc3b9f92176e2a1537a14" name="a8387bde500e78abd34b817796e0ab156a73ec08472eddc3b9f92176e2a1537a14"></a>kWarn&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27" name="a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27"></a>kInfo&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8387bde500e78abd34b817796e0ab156a92948dbbc0fe0cfbea020bbb04b58a04" name="a8387bde500e78abd34b817796e0ab156a92948dbbc0fe0cfbea020bbb04b58a04"></a>kTrace&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="logging_8h_source.html#l00009">9</a> of file <a class="el" href="logging_8h_source.html">logging.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">    9</span>{ <a class="code hl_enumvalue" href="#a8387bde500e78abd34b817796e0ab156a56dc8400798e5d1c4812f2b96f484284">kError</a> = 0, <a class="code hl_enumvalue" href="#a8387bde500e78abd34b817796e0ab156a73ec08472eddc3b9f92176e2a1537a14">kWarn</a> = 1, <a class="code hl_enumvalue" href="#a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27">kInfo</a> = 2, <a class="code hl_enumvalue" href="#a8387bde500e78abd34b817796e0ab156a92948dbbc0fe0cfbea020bbb04b58a04">kTrace</a> = 3 };</div>
<div class="ttc" id="anamespacegpu_html_a8387bde500e78abd34b817796e0ab156a56dc8400798e5d1c4812f2b96f484284"><div class="ttname"><a href="#a8387bde500e78abd34b817796e0ab156a56dc8400798e5d1c4812f2b96f484284">gpu::kError</a></div><div class="ttdeci">@ kError</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00009">logging.h:9</a></div></div>
<div class="ttc" id="anamespacegpu_html_a8387bde500e78abd34b817796e0ab156a73ec08472eddc3b9f92176e2a1537a14"><div class="ttname"><a href="#a8387bde500e78abd34b817796e0ab156a73ec08472eddc3b9f92176e2a1537a14">gpu::kWarn</a></div><div class="ttdeci">@ kWarn</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00009">logging.h:9</a></div></div>
<div class="ttc" id="anamespacegpu_html_a8387bde500e78abd34b817796e0ab156a92948dbbc0fe0cfbea020bbb04b58a04"><div class="ttname"><a href="#a8387bde500e78abd34b817796e0ab156a92948dbbc0fe0cfbea020bbb04b58a04">gpu::kTrace</a></div><div class="ttdeci">@ kTrace</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00009">logging.h:9</a></div></div>
<div class="ttc" id="anamespacegpu_html_a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27"><div class="ttname"><a href="#a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27">gpu::kInfo</a></div><div class="ttdeci">@ kInfo</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00009">logging.h:9</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7641c2218622a47af47216dc8b053fa9" name="a7641c2218622a47af47216dc8b053fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7641c2218622a47af47216dc8b053fa9">&#9670;&#160;</a></span>NumType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a7641c2218622a47af47216dc8b053fa9">gpu::NumType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe" name="a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe"></a>kf32&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00182">182</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  182</span>{ <a class="code hl_enumvalue" href="#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">kf32</a> };</div>
<div class="ttc" id="anamespacegpu_html_a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe"><div class="ttname"><a href="#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">gpu::kf32</a></div><div class="ttdeci">@ kf32</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00182">gpu.h:182</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adfdffb34c646d3410de7e261caebdcd1" name="adfdffb34c646d3410de7e261caebdcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdffb34c646d3410de7e261caebdcd1">&#9670;&#160;</a></span>Bindings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gpu::Bindings </td>
          <td>(</td>
          <td class="paramtype">Args...</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  Bindings&lt; sizeof...(Args)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a800a846dae86c7d779a50139fac8224a" name="a800a846dae86c7d779a50139fac8224a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800a846dae86c7d779a50139fac8224a">&#9670;&#160;</a></span>Bindings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gpu::Bindings </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="structgpu_1_1_tensor.html">Tensor</a>, N &gt;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> -&gt;  Bindings&lt; N &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduction guide for <a class="el" href="structgpu_1_1_bindings.html" title="Represents an ordered collection of WGPUBuffers (wrapped as tensors, non-overlapping views,...">Bindings</a>. </p>

</div>
</div>
<a id="aea8678985df08ea0baed925266b5e43f" name="aea8678985df08ea0baed925266b5e43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8678985df08ea0baed925266b5e43f">&#9670;&#160;</a></span>cdiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_shape.html">Shape</a> gpu::cdiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_shape.html">Shape</a></td>          <td class="paramname"><span class="paramname"><em>total</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_shape.html">Shape</a></td>          <td class="paramname"><span class="paramname"><em>group</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cdiv for shape specification. Mostly useful for evenly dividing total </p>
<h1><a class="anchor" id="autotoc_md0"></a>
threads by workgroup size dimensions.</h1>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00873">873</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  873</span>                                            {</div>
<div class="line"><span class="lineno">  874</span>  assert(total.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a> == group.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a>);</div>
<div class="line"><span class="lineno">  875</span>  <a class="code hl_struct" href="structgpu_1_1_shape.html">Shape</a> result;</div>
<div class="line"><span class="lineno">  876</span>  result.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a> = total.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a>;</div>
<div class="line"><span class="lineno">  877</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> dim = 0; dim &lt; total.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a>; ++dim) {</div>
<div class="line"><span class="lineno">  878</span>    result[dim] = <a class="code hl_function" href="#ae639cf27d731534ea42a77b63f928c88">cdiv</a>(total[dim], group[dim]);</div>
<div class="line"><span class="lineno">  879</span>  }</div>
<div class="line"><span class="lineno">  880</span>  <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  881</span>}</div>
<div class="ttc" id="anamespacegpu_html_ae639cf27d731534ea42a77b63f928c88"><div class="ttname"><a href="#ae639cf27d731534ea42a77b63f928c88">gpu::cdiv</a></div><div class="ttdeci">size_t cdiv(size_t n, size_t d)</div><div class="ttdoc">Ceiling division.</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00867">gpu.h:867</a></div></div>
<div class="ttc" id="astructgpu_1_1_shape_html"><div class="ttname"><a href="structgpu_1_1_shape.html">gpu::Shape</a></div><div class="ttdoc">Represents the shape of a tensor.</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00048">gpu.h:48</a></div></div>
<div class="ttc" id="astructgpu_1_1_shape_html_a0a0e6afec8c276bd46d6b9a8f9a2244e"><div class="ttname"><a href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">gpu::Shape::rank</a></div><div class="ttdeci">size_t rank</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00052">gpu.h:52</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae639cf27d731534ea42a77b63f928c88" name="ae639cf27d731534ea42a77b63f928c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae639cf27d731534ea42a77b63f928c88">&#9670;&#160;</a></span>cdiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gpu::cdiv </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ceiling division. </p>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00867">867</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  867</span>{ <span class="keywordflow">return</span> (n + d - 1) / d; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e8bcb1dd85ad12c99d6f27ace6d891a" name="a3e8bcb1dd85ad12c99d6f27ace6d891a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8bcb1dd85ad12c99d6f27ace6d891a">&#9670;&#160;</a></span>check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::check </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>file</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;unkown&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks a condition and logs an error message if the condition is false. In debug mode, it will also exit the program with an error code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The condition to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The error message to log if the condition is false. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>The source file where the check is performed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>The line number in the source file where the check is performed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00575">575</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  576</span>                                                              {</div>
<div class="line"><span class="lineno">  577</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (<a class="code hl_variable" href="#aa260b4aa723e3754e338952a00a00fa5">kDebug</a>) {</div>
<div class="line"><span class="lineno">  578</span>    <span class="keywordflow">if</span> (!condition) {</div>
<div class="line"><span class="lineno">  579</span>      <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kError, <span class="stringliteral">&quot;Error in file %s line %d:\n%s&quot;</span>, file, line,</div>
<div class="line"><span class="lineno">  580</span>          message);</div>
<div class="line"><span class="lineno">  581</span>      exit(1);</div>
<div class="line"><span class="lineno">  582</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  583</span>      LOG(kDefLog, kTrace, <span class="stringliteral">&quot;Success in file %s line %d:\n%s&quot;</span>, file, line,</div>
<div class="line"><span class="lineno">  584</span>          message);</div>
<div class="line"><span class="lineno">  585</span>    }</div>
<div class="line"><span class="lineno">  586</span>  }</div>
<div class="line"><span class="lineno">  587</span>}</div>
<div class="ttc" id="anamespacegpu_html_a508fff3f15882a37b1c0bd0341296176"><div class="ttname"><a href="#a508fff3f15882a37b1c0bd0341296176">gpu::LOG</a></div><div class="ttdeci">void LOG(Logger &amp;logger, int level, const char *message,...)</div><div class="ttdoc">Log a message to the logger. If NDEBUG is defined in a source or as a compiler flag,...</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00034">logging.h:34</a></div></div>
<div class="ttc" id="anamespacegpu_html_aa260b4aa723e3754e338952a00a00fa5"><div class="ttname"><a href="#aa260b4aa723e3754e338952a00a00fa5">gpu::kDebug</a></div><div class="ttdeci">static constexpr bool kDebug</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00023">gpu.h:23</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d4931274b4522b102e4e98c5f056768" name="a1d4931274b4522b102e4e98c5f056768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4931274b4522b102e4e98c5f056768">&#9670;&#160;</a></span>createContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_context.html">Context</a> gpu::createContext </td>
          <td>(</td>
          <td class="paramtype">const WGPUInstanceDescriptor &amp;</td>          <td class="paramname"><span class="paramname"><em>desc</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WGPURequestAdapterOptions &amp;</td>          <td class="paramname"><span class="paramname"><em>adapterOpts</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WGPUDeviceDescriptor</td>          <td class="paramname"><span class="paramname"><em>devDescriptor</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory function to create a GPU context, which aggregates WebGPU API handles to interact with the GPU including the instance, adapter, device, and queue. </p>
<p>The function takes optional descriptor parameters for the instance descriptor, adapter request options, and device descriptor, which are passed through to the WebGPU API calls to create the instance, adapter, and device.</p>
<p>If dawn is used, it also sets up an error callback for device loss.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Instance descriptor for the WebGPU instance (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adapterOpts</td><td>Adapter request options for the WebGPU adapter (optional) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">devDescriptor</td><td>Device descriptor for the WebGPU device (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance representing the created GPU context</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgpu_1_1_context.html">Context</a> ctx = <a class="code hl_function" href="#a1d4931274b4522b102e4e98c5f056768">createContext</a>();</div>
<div class="ttc" id="anamespacegpu_html_a1d4931274b4522b102e4e98c5f056768"><div class="ttname"><a href="#a1d4931274b4522b102e4e98c5f056768">gpu::createContext</a></div><div class="ttdeci">Context createContext(const WGPUInstanceDescriptor &amp;desc={}, const WGPURequestAdapterOptions &amp;adapterOpts={}, WGPUDeviceDescriptor devDescriptor={})</div><div class="ttdoc">Factory function to create a GPU context, which aggregates WebGPU API handles to interact with the GP...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00610">gpu.h:610</a></div></div>
<div class="ttc" id="astructgpu_1_1_context_html"><div class="ttname"><a href="structgpu_1_1_context.html">gpu::Context</a></div><div class="ttdoc">Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00390">gpu.h:390</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00610">610</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  610</span>                                                                  {},</div>
<div class="line"><span class="lineno">  611</span>                             <span class="keyword">const</span> WGPURequestAdapterOptions &amp;adapterOpts = {},</div>
<div class="line"><span class="lineno">  612</span>                             WGPUDeviceDescriptor devDescriptor = {}) {</div>
<div class="line"><span class="lineno">  613</span>  Context context;</div>
<div class="line"><span class="lineno">  614</span>  {</div>
<div class="line"><span class="lineno">  615</span>    context.instance = wgpuCreateInstance(&amp;desc);</div>
<div class="line"><span class="lineno">  616</span>    <a class="code hl_function" href="#a3e8bcb1dd85ad12c99d6f27ace6d891a">check</a>(context.instance, <span class="stringliteral">&quot;Initialize WebGPU&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"><span class="lineno">  617</span>  }</div>
<div class="line"><span class="lineno">  618</span>  <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kInfo, <span class="stringliteral">&quot;Requesting adapter&quot;</span>);</div>
<div class="line"><span class="lineno">  619</span>  {</div>
<div class="line"><span class="lineno">  620</span>    <span class="keyword">struct </span>AdapterData {</div>
<div class="line"><span class="lineno">  621</span>      WGPUAdapter adapter = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  622</span>      <span class="keywordtype">bool</span> requestEnded = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  623</span>    };</div>
<div class="line"><span class="lineno">  624</span>    AdapterData adapterData;</div>
<div class="line"><span class="lineno">  625</span>    <span class="keyword">auto</span> onAdapterRequestEnded = [](WGPURequestAdapterStatus status,</div>
<div class="line"><span class="lineno">  626</span>                                    WGPUAdapter adapter, <span class="keywordtype">char</span> <span class="keyword">const</span> *message,</div>
<div class="line"><span class="lineno">  627</span>                                    <span class="keywordtype">void</span> *pUserData) {</div>
<div class="line"><span class="lineno">  628</span>      AdapterData &amp;adapterData = *<span class="keyword">reinterpret_cast&lt;</span>AdapterData *<span class="keyword">&gt;</span>(pUserData);</div>
<div class="line"><span class="lineno">  629</span>      <a class="code hl_function" href="#a3e8bcb1dd85ad12c99d6f27ace6d891a">check</a>(status == WGPURequestAdapterStatus_Success,</div>
<div class="line"><span class="lineno">  630</span>            <span class="stringliteral">&quot;Request WebGPU adapter&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"><span class="lineno">  631</span>      adapterData.adapter = adapter;</div>
<div class="line"><span class="lineno">  632</span>      adapterData.requestEnded = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  633</span>    };</div>
<div class="line"><span class="lineno">  634</span>    wgpuInstanceRequestAdapter(context.instance, &amp;adapterOpts,</div>
<div class="line"><span class="lineno">  635</span>                               onAdapterRequestEnded, (<span class="keywordtype">void</span> *)&amp;adapterData);</div>
<div class="line"><span class="lineno">  636</span>    assert(adapterData.requestEnded);</div>
<div class="line"><span class="lineno">  637</span>    context.adapter = adapterData.adapter;</div>
<div class="line"><span class="lineno">  638</span>  }</div>
<div class="line"><span class="lineno">  639</span>  <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kInfo, <span class="stringliteral">&quot;Requesting device&quot;</span>);</div>
<div class="line"><span class="lineno">  640</span>  {</div>
<div class="line"><span class="lineno">  641</span>    <span class="keyword">struct </span>DeviceData {</div>
<div class="line"><span class="lineno">  642</span>      WGPUDevice device = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  643</span>      <span class="keywordtype">bool</span> requestEnded = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  644</span>    };</div>
<div class="line"><span class="lineno">  645</span>    DeviceData devData;</div>
<div class="line"><span class="lineno">  646</span>    <span class="keyword">auto</span> onDeviceRequestEnded = [](WGPURequestDeviceStatus status,</div>
<div class="line"><span class="lineno">  647</span>                                   WGPUDevice device, <span class="keywordtype">char</span> <span class="keyword">const</span> *message,</div>
<div class="line"><span class="lineno">  648</span>                                   <span class="keywordtype">void</span> *pUserData) {</div>
<div class="line"><span class="lineno">  649</span>      DeviceData &amp;devData = *<span class="keyword">reinterpret_cast&lt;</span>DeviceData *<span class="keyword">&gt;</span>(pUserData);</div>
<div class="line"><span class="lineno">  650</span>      <a class="code hl_function" href="#a3e8bcb1dd85ad12c99d6f27ace6d891a">check</a>(status == WGPURequestDeviceStatus_Success,</div>
<div class="line"><span class="lineno">  651</span>            <span class="stringliteral">&quot;Could not get WebGPU device.&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"><span class="lineno">  652</span>      <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kTrace, <span class="stringliteral">&quot;Device Request succeeded %x&quot;</span>,</div>
<div class="line"><span class="lineno">  653</span>          <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(device));</div>
<div class="line"><span class="lineno">  654</span>      devData.device = device;</div>
<div class="line"><span class="lineno">  655</span>      devData.requestEnded = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  656</span>    };</div>
<div class="line"><span class="lineno">  657</span> </div>
<div class="line"><span class="lineno">  658</span><span class="preprocessor">#ifdef WEBGPU_BACKEND_DAWN</span></div>
<div class="line"><span class="lineno">  659</span>    devDescriptor.deviceLostCallbackInfo = {</div>
<div class="line"><span class="lineno">  660</span>        .callback =</div>
<div class="line"><span class="lineno">  661</span>            [](WGPUDevice <span class="keyword">const</span> *device, WGPUDeviceLostReason reason,</div>
<div class="line"><span class="lineno">  662</span>               <span class="keywordtype">char</span> <span class="keyword">const</span> *message, <span class="keywordtype">void</span> *userdata) {</div>
<div class="line"><span class="lineno">  663</span>              <span class="keywordflow">if</span> (reason != WGPUDeviceLostReason_Destroyed) {</div>
<div class="line"><span class="lineno">  664</span>                <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kError, <span class="stringliteral">&quot;Device lost (code %d):\n%s&quot;</span>, reason,</div>
<div class="line"><span class="lineno">  665</span>                    message);</div>
<div class="line"><span class="lineno">  666</span>              } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  667</span>                <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kInfo, <span class="stringliteral">&quot;Device destroyed: %s&quot;</span>, message);</div>
<div class="line"><span class="lineno">  668</span>              }</div>
<div class="line"><span class="lineno">  669</span>            },</div>
<div class="line"><span class="lineno">  670</span>    };</div>
<div class="line"><span class="lineno">  671</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  672</span> </div>
<div class="line"><span class="lineno">  673</span>    wgpuAdapterRequestDevice(context.adapter, &amp;devDescriptor,</div>
<div class="line"><span class="lineno">  674</span>                             onDeviceRequestEnded, (<span class="keywordtype">void</span> *)&amp;devData);</div>
<div class="line"><span class="lineno">  675</span>    assert(devData.requestEnded);</div>
<div class="line"><span class="lineno">  676</span>    context.device = devData.device;</div>
<div class="line"><span class="lineno">  677</span>    wgpuDeviceSetUncapturedErrorCallback(</div>
<div class="line"><span class="lineno">  678</span>        context.device,</div>
<div class="line"><span class="lineno">  679</span>        [](WGPUErrorType type, <span class="keywordtype">char</span> <span class="keyword">const</span> *message, <span class="keywordtype">void</span> *devData) {</div>
<div class="line"><span class="lineno">  680</span>          LOG(kDefLog, kError, <span class="stringliteral">&quot;Device uncaptured error: %s&quot;</span>, message);</div>
<div class="line"><span class="lineno">  681</span>          throw std::runtime_error(<span class="stringliteral">&quot;Device uncaptured exception.&quot;</span>);</div>
<div class="line"><span class="lineno">  682</span>        },</div>
<div class="line"><span class="lineno">  683</span>        <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  684</span>  }</div>
<div class="line"><span class="lineno">  685</span>  context.queue = wgpuDeviceGetQueue(context.device);</div>
<div class="line"><span class="lineno">  686</span>  <span class="keywordflow">return</span> context;</div>
<div class="line"><span class="lineno">  687</span>}</div>
<div class="ttc" id="anamespacegpu_html_a3e8bcb1dd85ad12c99d6f27ace6d891a"><div class="ttname"><a href="#a3e8bcb1dd85ad12c99d6f27ace6d891a">gpu::check</a></div><div class="ttdeci">void check(bool condition, const char *message, const char *file=&quot;unkown&quot;, int line=-1)</div><div class="ttdoc">Checks a condition and logs an error message if the condition is false. In debug mode,...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00575">gpu.h:575</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1b3f405db18bafc2e79f10b82f94f8b" name="aa1b3f405db18bafc2e79f10b82f94f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b3f405db18bafc2e79f10b82f94f8b">&#9670;&#160;</a></span>createKernel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ParamsType  = NoParam, size_t numInputs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a> gpu::createKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_kernel_code.html">KernelCode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_bindings.html">Bindings</a>&lt; numInputs &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dataBindings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nWorkgroups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParamsType &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">ParamsType{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload which wraps the createKernel factory function to create a kernel on the GPU. This overload uses takes a static collection of input tensors instead of a pointer and a statically determined ParamsType instead of casting params to a void pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>WGSL code for the kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataBindings</td><td>A <a class="el" href="structgpu_1_1_bindings.html" title="Represents an ordered collection of WGPUBuffers (wrapped as tensors, non-overlapping views,...">Bindings</a> of tensors whose GPU buffers are bound to the kernel as inputs and outputs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nWorkgroups</td><td>Number of workgroups in the x, y, z grid, must be a <a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> of rank == 3. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Optional parameters for the kernel. If the kernel does not have any parameters, use <a class="el" href="structgpu_1_1_no_param.html" title="NoParam is a no-op type used to indicate that a kernel does not have any parameters.">NoParam</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> instance representing the created kernel</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgpu_1_1_kernel.html">Kernel</a> kernel = <a class="code hl_function" href="#a62a564af334eff94a0fd4118c70e84f3">createKernel</a>(ctx, code, tensorData, output,</div>
<div class="ttc" id="anamespacegpu_html_a62a564af334eff94a0fd4118c70e84f3"><div class="ttname"><a href="#a62a564af334eff94a0fd4118c70e84f3">gpu::createKernel</a></div><div class="ttdeci">Kernel createKernel(Context &amp;ctx, const KernelCode &amp;code, const Tensor *dataBindings, size_t numTensors, const size_t *viewOffsets, const Shape &amp;nWorkgroups, const void *params=nullptr, size_t paramsSize=0)</div><div class="ttdoc">A factory function to create a kernel on the GPU. The kernel is created with the given WGSL code,...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00909">gpu.h:909</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_html"><div class="ttname"><a href="structgpu_1_1_kernel.html">gpu::Kernel</a></div><div class="ttdoc">Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00346">gpu.h:346</a></div></div>
</div><!-- fragment --><p> nWorkgroups, params); </p>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l01065">1065</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1068</span>                                                         {}) {</div>
<div class="line"><span class="lineno"> 1069</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (!IsNoParam&lt;ParamsType&gt;) {</div>
<div class="line"><span class="lineno"> 1070</span>    <span class="comment">// LOG(kDefLog, kTrace, &quot;Using params of size %d bytes&quot;,</span></div>
<div class="line"><span class="lineno"> 1071</span>    <span class="comment">// sizeof(ParamsType));</span></div>
<div class="line"><span class="lineno"> 1072</span>    <span class="keywordflow">return</span> createKernel(ctx, code, dataBindings.<a class="code hl_variable" href="structgpu_1_1_bindings.html#ae3c08de2be75853afcb03a5aa40ba304">data</a>.data(), numInputs,</div>
<div class="line"><span class="lineno"> 1073</span>                        dataBindings.<a class="code hl_variable" href="structgpu_1_1_bindings.html#ae09528d38daded0931b9d6ab4af8166d">viewOffsets</a>.data(), nWorkgroups,</div>
<div class="line"><span class="lineno"> 1074</span>                        <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(&amp;params),</div>
<div class="line"><span class="lineno"> 1075</span>                        <span class="keyword">sizeof</span>(ParamsType));</div>
<div class="line"><span class="lineno"> 1076</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno"> 1077</span>    <span class="comment">// LOG(kDefLog, kTrace , &quot;No params&quot;);</span></div>
<div class="line"><span class="lineno"> 1078</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="#a62a564af334eff94a0fd4118c70e84f3">createKernel</a>(ctx, code, dataBindings.<a class="code hl_variable" href="structgpu_1_1_bindings.html#ae3c08de2be75853afcb03a5aa40ba304">data</a>.data(), numInputs,</div>
<div class="line"><span class="lineno"> 1079</span>                        dataBindings.<a class="code hl_variable" href="structgpu_1_1_bindings.html#ae09528d38daded0931b9d6ab4af8166d">viewOffsets</a>.data(), nWorkgroups, <span class="keyword">nullptr</span>,</div>
<div class="line"><span class="lineno"> 1080</span>                        0);</div>
<div class="line"><span class="lineno"> 1081</span>  }</div>
<div class="line"><span class="lineno"> 1082</span>}</div>
<div class="ttc" id="astructgpu_1_1_bindings_html_ae09528d38daded0931b9d6ab4af8166d"><div class="ttname"><a href="structgpu_1_1_bindings.html#ae09528d38daded0931b9d6ab4af8166d">gpu::Bindings::viewOffsets</a></div><div class="ttdeci">std::array&lt; size_t, N &gt; viewOffsets</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00126">gpu.h:126</a></div></div>
<div class="ttc" id="astructgpu_1_1_bindings_html_ae3c08de2be75853afcb03a5aa40ba304"><div class="ttname"><a href="structgpu_1_1_bindings.html#ae3c08de2be75853afcb03a5aa40ba304">gpu::Bindings::data</a></div><div class="ttdeci">std::array&lt; Tensor, N &gt; data</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00125">gpu.h:125</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a62a564af334eff94a0fd4118c70e84f3" name="a62a564af334eff94a0fd4118c70e84f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a564af334eff94a0fd4118c70e84f3">&#9670;&#160;</a></span>createKernel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a> gpu::createKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_kernel_code.html">KernelCode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>code</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_tensor.html">Tensor</a> *</td>          <td class="paramname"><span class="paramname"><em>dataBindings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numTensors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *</td>          <td class="paramname"><span class="paramname"><em>viewOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nWorkgroups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>params</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>paramsSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A factory function to create a kernel on the GPU. The kernel is created with the given WGSL code, input tensors, output tensor, and optional parameters. </p>
<p>Note that the values of the input tensors are not used here, only the reference handles to the underlying buffers as well as the size of the buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>WGSL code for the kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataBindings</td><td>Pointer to a span of tensors bound to the kernel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numInputs</td><td>Number of tensors pointed to by dataBindings </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nThreads</td><td><a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> of the workgroup size for the kernel, must be of rank 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Optional parameters for the kernel. If the kernel does not have any parameters, use <a class="el" href="structgpu_1_1_no_param.html" title="NoParam is a no-op type used to indicate that a kernel does not have any parameters.">NoParam</a>. This is cast as void* to allow for arbitrary types to be passed as parameters. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsSize</td><td>Size of the parameters buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> instance representing the created kernel</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgpu_1_1_kernel.html">Kernel</a> kernel = <a class="code hl_function" href="#a62a564af334eff94a0fd4118c70e84f3">createKernel</a>(ctx, code, dataBindings, numInputs,</div>
</div><!-- fragment --><p> output, nThreads, params, paramsSize); </p>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00909">909</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  913</span>                                                  {</div>
<div class="line"><span class="lineno">  914</span>  assert(nWorkgroups.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a> == 3);</div>
<div class="line"><span class="lineno">  915</span>  WGPUDevice device = ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#ae810ad2a9cd07cd59e28a1da6965a7ba">device</a>;</div>
<div class="line"><span class="lineno">  916</span>  WGPUQueue queue = ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>;</div>
<div class="line"><span class="lineno">  917</span>  <a class="code hl_struct" href="structgpu_1_1_kernel.html">Kernel</a> op;</div>
<div class="line"><span class="lineno">  918</span>  <span class="comment">// paramIndex is the index into bgLayoutEntries for the parameters buffer If</span></div>
<div class="line"><span class="lineno">  919</span>  <span class="comment">// there are no parameters for the kernel, paramsSize == 0 and paramIndex is</span></div>
<div class="line"><span class="lineno">  920</span>  <span class="comment">// effectively undefined (== -1)</span></div>
<div class="line"><span class="lineno">  921</span>  <span class="keywordtype">size_t</span> paramIndex = -1;</div>
<div class="line"><span class="lineno">  922</span>  <span class="comment">// Note: paramIndex is undefined unless paramsSize &gt; 0</span></div>
<div class="line"><span class="lineno">  923</span>  <span class="keywordtype">size_t</span> numBindings = numTensors;</div>
<div class="line"><span class="lineno">  924</span>  <span class="keywordflow">if</span> (paramsSize &gt; 0) {</div>
<div class="line"><span class="lineno">  925</span>    numBindings++;                <span class="comment">// parameters buffer</span></div>
<div class="line"><span class="lineno">  926</span>    paramIndex = numBindings - 1; <span class="comment">// index of the parameters buffer within</span></div>
<div class="line"><span class="lineno">  927</span>                                  <span class="comment">// op.buffers, op.bufferSizes and</span></div>
<div class="line"><span class="lineno">  928</span>                                  <span class="comment">// bgLayoutEntries</span></div>
<div class="line"><span class="lineno">  929</span>  }</div>
<div class="line"><span class="lineno">  930</span>  op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">buffers</a> = std::make_unique&lt;WGPUBuffer[]&gt;(numBindings);</div>
<div class="line"><span class="lineno">  931</span>  op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a47efa9ca7930e5774964a651270ace44">bufferSizes</a> = std::make_unique&lt;size_t[]&gt;(numBindings);</div>
<div class="line"><span class="lineno">  932</span>  op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a552ac93214b23de9d252e0823adcd7ff">numBindings</a> = numBindings;</div>
<div class="line"><span class="lineno">  933</span>  std::vector&lt;WGPUBindGroupLayoutEntry&gt; bgLayoutEntries(numBindings);</div>
<div class="line"><span class="lineno">  934</span>  <span class="comment">// Create layout entries for input buffers</span></div>
<div class="line"><span class="lineno">  935</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numTensors; ++i) {</div>
<div class="line"><span class="lineno">  936</span>    bgLayoutEntries[i] = WGPUBindGroupLayoutEntry{</div>
<div class="line"><span class="lineno">  937</span>        .binding = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(i),</div>
<div class="line"><span class="lineno">  938</span>        .visibility = WGPUShaderStage_Compute,</div>
<div class="line"><span class="lineno">  939</span>        .buffer =</div>
<div class="line"><span class="lineno">  940</span>            WGPUBufferBindingLayout{</div>
<div class="line"><span class="lineno">  941</span>                .type = WGPUBufferBindingType_Storage,</div>
<div class="line"><span class="lineno">  942</span>                .minBindingSize = dataBindings[i].<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#a4dbb66b98ca78d85a755e11b3607c3e2">size</a>,</div>
<div class="line"><span class="lineno">  943</span>            },</div>
<div class="line"><span class="lineno">  944</span>    };</div>
<div class="line"><span class="lineno">  945</span>  }</div>
<div class="line"><span class="lineno">  946</span>  <span class="keywordflow">if</span> (paramsSize &gt; 0) {</div>
<div class="line"><span class="lineno">  947</span>    <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kInfo, <span class="stringliteral">&quot;Create layout entry for the params buffer&quot;</span>);</div>
<div class="line"><span class="lineno">  948</span>    <span class="comment">// Create layout entry for the params buffer</span></div>
<div class="line"><span class="lineno">  949</span>    bgLayoutEntries[paramIndex] = WGPUBindGroupLayoutEntry{</div>
<div class="line"><span class="lineno">  950</span>        .binding = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(paramIndex),</div>
<div class="line"><span class="lineno">  951</span>        .visibility = WGPUShaderStage_Compute,</div>
<div class="line"><span class="lineno">  952</span>        .buffer =</div>
<div class="line"><span class="lineno">  953</span>            WGPUBufferBindingLayout{</div>
<div class="line"><span class="lineno">  954</span>                .type = WGPUBufferBindingType_Uniform,</div>
<div class="line"><span class="lineno">  955</span>                .minBindingSize = paramsSize,</div>
<div class="line"><span class="lineno">  956</span>            },</div>
<div class="line"><span class="lineno">  957</span>    };</div>
<div class="line"><span class="lineno">  958</span>  }</div>
<div class="line"><span class="lineno">  959</span>  WGPUBindGroupLayoutDescriptor bgLayoutDesc = {</div>
<div class="line"><span class="lineno">  960</span>      .entryCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(bgLayoutEntries.size()),</div>
<div class="line"><span class="lineno">  961</span>      .entries = bgLayoutEntries.data(),</div>
<div class="line"><span class="lineno">  962</span>  };</div>
<div class="line"><span class="lineno">  963</span>  WGPUBindGroupLayout bgLayout =</div>
<div class="line"><span class="lineno">  964</span>      wgpuDeviceCreateBindGroupLayout(device, &amp;bgLayoutDesc);</div>
<div class="line"><span class="lineno">  965</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numTensors; ++i) {</div>
<div class="line"><span class="lineno">  966</span>    op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">buffers</a>[i] = dataBindings[i].<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>;</div>
<div class="line"><span class="lineno">  967</span>    op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a47efa9ca7930e5774964a651270ace44">bufferSizes</a>[i] = dataBindings[i].<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#a4dbb66b98ca78d85a755e11b3607c3e2">size</a>;</div>
<div class="line"><span class="lineno">  968</span>  }</div>
<div class="line"><span class="lineno">  969</span>  <span class="comment">// Create a buffer for the Params struct</span></div>
<div class="line"><span class="lineno">  970</span>  <span class="keywordflow">if</span> (paramsSize &gt; 0) {</div>
<div class="line"><span class="lineno">  971</span>    WGPUBufferDescriptor paramsBufferDesc = {</div>
<div class="line"><span class="lineno">  972</span>        .usage = WGPUBufferUsage_Uniform | WGPUBufferUsage_CopyDst,</div>
<div class="line"><span class="lineno">  973</span>        .size = paramsSize,</div>
<div class="line"><span class="lineno">  974</span>        .mappedAtCreation = <span class="keyword">false</span>,</div>
<div class="line"><span class="lineno">  975</span>    };</div>
<div class="line"><span class="lineno">  976</span>    op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">buffers</a>[paramIndex] = wgpuDeviceCreateBuffer(device, &amp;paramsBufferDesc);</div>
<div class="line"><span class="lineno">  977</span>    op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a47efa9ca7930e5774964a651270ace44">bufferSizes</a>[paramIndex] = paramsSize;</div>
<div class="line"><span class="lineno">  978</span>    wgpuQueueWriteBuffer(queue, op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">buffers</a>[paramIndex], 0, params, paramsSize);</div>
<div class="line"><span class="lineno">  979</span>    <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kTrace, <span class="stringliteral">&quot;Params buffer written&quot;</span>);</div>
<div class="line"><span class="lineno">  980</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  981</span>    <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kTrace, <span class="stringliteral">&quot;No params buffer needed&quot;</span>);</div>
<div class="line"><span class="lineno">  982</span>  }</div>
<div class="line"><span class="lineno">  983</span>  std::vector&lt;WGPUBindGroupEntry&gt; bindGroupEntries(numBindings);</div>
<div class="line"><span class="lineno">  984</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; numTensors; ++i) {</div>
<div class="line"><span class="lineno">  985</span>    bindGroupEntries[i] = WGPUBindGroupEntry{</div>
<div class="line"><span class="lineno">  986</span>        .binding = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(i),</div>
<div class="line"><span class="lineno">  987</span>        .buffer = op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">buffers</a>[i],</div>
<div class="line"><span class="lineno">  988</span>        .offset = viewOffsets[i],</div>
<div class="line"><span class="lineno">  989</span>        .size = op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a47efa9ca7930e5774964a651270ace44">bufferSizes</a>[i],</div>
<div class="line"><span class="lineno">  990</span>    };</div>
<div class="line"><span class="lineno">  991</span>  }</div>
<div class="line"><span class="lineno">  992</span>  <span class="keywordflow">if</span> (paramsSize &gt; 0) {</div>
<div class="line"><span class="lineno">  993</span>    <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kInfo, <span class="stringliteral">&quot;Create bind group entry for the params buffer&quot;</span>);</div>
<div class="line"><span class="lineno">  994</span>    <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kInfo, <span class="stringliteral">&quot;paramIndex: %d&quot;</span>, paramIndex);</div>
<div class="line"><span class="lineno">  995</span>    bindGroupEntries[paramIndex] = WGPUBindGroupEntry{</div>
<div class="line"><span class="lineno">  996</span>        .binding = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(paramIndex),</div>
<div class="line"><span class="lineno">  997</span>        .buffer = op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">buffers</a>[paramIndex],</div>
<div class="line"><span class="lineno">  998</span>        .offset = 0,</div>
<div class="line"><span class="lineno">  999</span>        .size = paramsSize,</div>
<div class="line"><span class="lineno"> 1000</span>    };</div>
<div class="line"><span class="lineno"> 1001</span>  }</div>
<div class="line"><span class="lineno"> 1002</span>  <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kTrace, <span class="stringliteral">&quot;BG Entries Size: %d&quot;</span>, numBindings);</div>
<div class="line"><span class="lineno"> 1003</span>  WGPUBindGroupDescriptor bindGroupDesc = {</div>
<div class="line"><span class="lineno"> 1004</span>      .layout = bgLayout,</div>
<div class="line"><span class="lineno"> 1005</span>      .entryCount = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(numBindings),</div>
<div class="line"><span class="lineno"> 1006</span>      .entries = bindGroupEntries.data(),</div>
<div class="line"><span class="lineno"> 1007</span>  };</div>
<div class="line"><span class="lineno"> 1008</span>  op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#ab3c829286d3d649f9d6888288f132e41">bindGroup</a> = wgpuDeviceCreateBindGroup(device, &amp;bindGroupDesc);</div>
<div class="line"><span class="lineno"> 1009</span>  {</div>
<div class="line"><span class="lineno"> 1010</span>    WGPUPipelineLayoutDescriptor pipelineLayoutDesc = {</div>
<div class="line"><span class="lineno"> 1011</span>        .bindGroupLayoutCount = 1,</div>
<div class="line"><span class="lineno"> 1012</span>        .bindGroupLayouts = &amp;bgLayout,</div>
<div class="line"><span class="lineno"> 1013</span>    };</div>
<div class="line"><span class="lineno"> 1014</span>    WGPUPipelineLayout pipelineLayout =</div>
<div class="line"><span class="lineno"> 1015</span>        wgpuDeviceCreatePipelineLayout(device, &amp;pipelineLayoutDesc);</div>
<div class="line"><span class="lineno"> 1016</span>    WGPUShaderModuleWGSLDescriptor wgslDesc = {</div>
<div class="line"><span class="lineno"> 1017</span>        .code = code.<a class="code hl_variable" href="structgpu_1_1_kernel_code.html#a2ad15822c743263eb63ef98eb7456818">data</a>.c_str(),</div>
<div class="line"><span class="lineno"> 1018</span>    };</div>
<div class="line"><span class="lineno"> 1019</span>    wgslDesc.chain.sType = WGPUSType_ShaderModuleWGSLDescriptor;</div>
<div class="line"><span class="lineno"> 1020</span>    WGPUShaderModuleDescriptor shaderModuleDesc = {};</div>
<div class="line"><span class="lineno"> 1021</span>    shaderModuleDesc.nextInChain = &amp;wgslDesc.chain;</div>
<div class="line"><span class="lineno"> 1022</span>    shaderModuleDesc.label = code.<a class="code hl_variable" href="structgpu_1_1_kernel_code.html#aadbebd728ce096c0458ae507e3f379bf">label</a>.c_str();</div>
<div class="line"><span class="lineno"> 1023</span>    WGPUComputePipelineDescriptor computePipelineDesc = {};</div>
<div class="line"><span class="lineno"> 1024</span>    computePipelineDesc.layout = pipelineLayout;</div>
<div class="line"><span class="lineno"> 1025</span>    computePipelineDesc.compute.module =</div>
<div class="line"><span class="lineno"> 1026</span>        wgpuDeviceCreateShaderModule(device, &amp;shaderModuleDesc);</div>
<div class="line"><span class="lineno"> 1027</span>    computePipelineDesc.compute.entryPoint = code.<a class="code hl_variable" href="structgpu_1_1_kernel_code.html#a27e10760b792860a6ad635f8057e687d">entryPoint</a>.c_str();</div>
<div class="line"><span class="lineno"> 1028</span>    computePipelineDesc.label = code.<a class="code hl_variable" href="structgpu_1_1_kernel_code.html#aadbebd728ce096c0458ae507e3f379bf">label</a>.c_str();</div>
<div class="line"><span class="lineno"> 1029</span>    op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aa8aaca0b5f23c2991b0d74fa6cfd1967">computePipeline</a> =</div>
<div class="line"><span class="lineno"> 1030</span>        wgpuDeviceCreateComputePipeline(device, &amp;computePipelineDesc);</div>
<div class="line"><span class="lineno"> 1031</span>  }</div>
<div class="line"><span class="lineno"> 1032</span>  <span class="comment">/*</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="comment">  op.nWorkgroups = {cdiv(nThreads[0], code.workgroupSize[0]),</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="comment">                    cdiv(nThreads[1], code.workgroupSize[1]),</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="comment">                    cdiv(nThreads[2], code.workgroupSize[2])};</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="comment">  */</span></div>
<div class="line"><span class="lineno"> 1037</span>  op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aec962f96d74dd1f3144c138030b14446">nWorkgroups</a> = {nWorkgroups[0], nWorkgroups[1], nWorkgroups[2]};</div>
<div class="line"><span class="lineno"> 1038</span>  <a class="code hl_function" href="#ac59323bc390c2a01dc473dcb72d03868">resetCommandBuffer</a>(device, op);</div>
<div class="line"><span class="lineno"> 1039</span>  ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#aa4098b7ad968c4558aef2ced17812ca0">kernelPool</a>.<a class="code hl_variable" href="structgpu_1_1_kernel_pool.html#a14be3fcb1e16529602f3f32f65ae4a30">data</a>.insert(&amp;op);</div>
<div class="line"><span class="lineno"> 1040</span>  <span class="keywordflow">return</span> op;</div>
<div class="line"><span class="lineno"> 1041</span>}</div>
<div class="ttc" id="anamespacegpu_html_ac59323bc390c2a01dc473dcb72d03868"><div class="ttname"><a href="#ac59323bc390c2a01dc473dcb72d03868">gpu::resetCommandBuffer</a></div><div class="ttdeci">void resetCommandBuffer(WGPUDevice &amp;device, Kernel &amp;op)</div><div class="ttdoc">Resets the command buffer in preparation for a kernel dispatch. Since command buffers are consumed up...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00840">gpu.h:840</a></div></div>
<div class="ttc" id="astructgpu_1_1_array_html_a4dbb66b98ca78d85a755e11b3607c3e2"><div class="ttname"><a href="structgpu_1_1_array.html#a4dbb66b98ca78d85a755e11b3607c3e2">gpu::Array::size</a></div><div class="ttdeci">size_t size</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00034">gpu.h:34</a></div></div>
<div class="ttc" id="astructgpu_1_1_array_html_ac4df84a36b0d7c8f1dbf54adfe999ad8"><div class="ttname"><a href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">gpu::Array::buffer</a></div><div class="ttdeci">WGPUBuffer buffer</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00032">gpu.h:32</a></div></div>
<div class="ttc" id="astructgpu_1_1_context_html_a6e289f57ee9bfa539477ecf18726242e"><div class="ttname"><a href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">gpu::Context::queue</a></div><div class="ttdeci">WGPUQueue queue</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00394">gpu.h:394</a></div></div>
<div class="ttc" id="astructgpu_1_1_context_html_aa4098b7ad968c4558aef2ced17812ca0"><div class="ttname"><a href="structgpu_1_1_context.html#aa4098b7ad968c4558aef2ced17812ca0">gpu::Context::kernelPool</a></div><div class="ttdeci">KernelPool kernelPool</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00396">gpu.h:396</a></div></div>
<div class="ttc" id="astructgpu_1_1_context_html_ae810ad2a9cd07cd59e28a1da6965a7ba"><div class="ttname"><a href="structgpu_1_1_context.html#ae810ad2a9cd07cd59e28a1da6965a7ba">gpu::Context::device</a></div><div class="ttdeci">WGPUDevice device</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00393">gpu.h:393</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_code_html_a27e10760b792860a6ad635f8057e687d"><div class="ttname"><a href="structgpu_1_1_kernel_code.html#a27e10760b792860a6ad635f8057e687d">gpu::KernelCode::entryPoint</a></div><div class="ttdeci">std::string entryPoint</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00305">gpu.h:305</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_code_html_a2ad15822c743263eb63ef98eb7456818"><div class="ttname"><a href="structgpu_1_1_kernel_code.html#a2ad15822c743263eb63ef98eb7456818">gpu::KernelCode::data</a></div><div class="ttdeci">std::string data</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00301">gpu.h:301</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_code_html_aadbebd728ce096c0458ae507e3f379bf"><div class="ttname"><a href="structgpu_1_1_kernel_code.html#aadbebd728ce096c0458ae507e3f379bf">gpu::KernelCode::label</a></div><div class="ttdeci">std::string label</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00304">gpu.h:304</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_html_a47efa9ca7930e5774964a651270ace44"><div class="ttname"><a href="structgpu_1_1_kernel.html#a47efa9ca7930e5774964a651270ace44">gpu::Kernel::bufferSizes</a></div><div class="ttdeci">std::unique_ptr&lt; size_t[]&gt; bufferSizes</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00348">gpu.h:348</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_html_a552ac93214b23de9d252e0823adcd7ff"><div class="ttname"><a href="structgpu_1_1_kernel.html#a552ac93214b23de9d252e0823adcd7ff">gpu::Kernel::numBindings</a></div><div class="ttdeci">size_t numBindings</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00349">gpu.h:349</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_html_aa8aaca0b5f23c2991b0d74fa6cfd1967"><div class="ttname"><a href="structgpu_1_1_kernel.html#aa8aaca0b5f23c2991b0d74fa6cfd1967">gpu::Kernel::computePipeline</a></div><div class="ttdeci">WGPUComputePipeline computePipeline</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00352">gpu.h:352</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_html_ab3c829286d3d649f9d6888288f132e41"><div class="ttname"><a href="structgpu_1_1_kernel.html#ab3c829286d3d649f9d6888288f132e41">gpu::Kernel::bindGroup</a></div><div class="ttdeci">WGPUBindGroup bindGroup</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00351">gpu.h:351</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_html_aec962f96d74dd1f3144c138030b14446"><div class="ttname"><a href="structgpu_1_1_kernel.html#aec962f96d74dd1f3144c138030b14446">gpu::Kernel::nWorkgroups</a></div><div class="ttdeci">Shape nWorkgroups</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00350">gpu.h:350</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_html_aecc74359af917ca7f6937beda8b21a24"><div class="ttname"><a href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">gpu::Kernel::buffers</a></div><div class="ttdeci">std::unique_ptr&lt; WGPUBuffer[]&gt; buffers</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00347">gpu.h:347</a></div></div>
<div class="ttc" id="astructgpu_1_1_kernel_pool_html_a14be3fcb1e16529602f3f32f65ae4a30"><div class="ttname"><a href="structgpu_1_1_kernel_pool.html#a14be3fcb1e16529602f3f32f65ae4a30">gpu::KernelPool::data</a></div><div class="ttdeci">std::set&lt; Kernel * &gt; data</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00374">gpu.h:374</a></div></div>
<div class="ttc" id="astructgpu_1_1_tensor_html_abc63dd485f74fa62eb8ee63f1b5ec767"><div class="ttname"><a href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">gpu::Tensor::data</a></div><div class="ttdeci">Array data</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00097">gpu.h:97</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a358e3c3540b76f01a7b991d0356e6f2f" name="a358e3c3540b76f01a7b991d0356e6f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358e3c3540b76f01a7b991d0356e6f2f">&#9670;&#160;</a></span>createTensor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a> gpu::createTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the tensor factory function to instantiate a tensor on the GPU with a given shape and data type. </p>
<p>Instead of taking the TensoPool and raw WebGPU API WGPUDevice and WGPUBufferUsageFlags arguments, this is a convenience wrapper around the core createTensor function which has default usage flags for a storage buffer, and also takes in the <a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> object.</p>
<p>instance instead of the narrower <a class="el" href="structgpu_1_1_tensor_pool.html" title="Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifeti...">TensorPool</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td><a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> of the tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtype</td><td>Data type of the tensor (e.g. kf32) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance representing the created tensor</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgpu_1_1_tensor.html">Tensor</a> tensor = <a class="code hl_function" href="#a49f54c3a36e4b4d7756995c7211bc212">createTensor</a>(ctx, {256, 256}, <a class="code hl_enumvalue" href="#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">kf32</a>);</div>
<div class="ttc" id="anamespacegpu_html_a49f54c3a36e4b4d7756995c7211bc212"><div class="ttname"><a href="#a49f54c3a36e4b4d7756995c7211bc212">gpu::createTensor</a></div><div class="ttdeci">Tensor createTensor(TensorPool &amp;pool, WGPUDevice &amp;device, const Shape &amp;shape, NumType dtype, WGPUBufferUsageFlags usage=WGPUBufferUsage_Storage|WGPUBufferUsage_CopyDst|WGPUBufferUsage_CopySrc)</div><div class="ttdoc">Tensor factory function to create a tensor (a Tensor type is simply an Array with an N-dimensional Sh...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00448">gpu.h:448</a></div></div>
<div class="ttc" id="astructgpu_1_1_tensor_html"><div class="ttname"><a href="structgpu_1_1_tensor.html">gpu::Tensor</a></div><div class="ttdoc">Represents a tensor on the GPU, which is a buffer of values with a shape.</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00096">gpu.h:96</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00491">491</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  491</span>                                                                            {</div>
<div class="line"><span class="lineno">  492</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="#a49f54c3a36e4b4d7756995c7211bc212">createTensor</a>(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6bf6ba07b846f568ccd0deebeacf258c">pool</a>, ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#ae810ad2a9cd07cd59e28a1da6965a7ba">device</a>, shape, dtype);</div>
<div class="line"><span class="lineno">  493</span>}</div>
<div class="ttc" id="astructgpu_1_1_context_html_a6bf6ba07b846f568ccd0deebeacf258c"><div class="ttname"><a href="structgpu_1_1_context.html#a6bf6ba07b846f568ccd0deebeacf258c">gpu::Context::pool</a></div><div class="ttdeci">TensorPool pool</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00395">gpu.h:395</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a20b9e45c7c54c6e69e93101737cedcd7" name="a20b9e45c7c54c6e69e93101737cedcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b9e45c7c54c6e69e93101737cedcd7">&#9670;&#160;</a></span>createTensor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a> gpu::createTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the tensor factory function to instantiate a tensor on the GPU with a given shape, data type. Unlike the other overloads, this overload also takes initial data to populate the tensor with. </p>
<p>The data is assumed to be of size equal to the product of the dimensions in the shape, and is copied to the GPU buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td><a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> of the tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtype</td><td>Data type of the tensor (e.g. kf32) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Initial data to populate the tensor with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance representing the created tensor</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgpu_1_1_tensor.html">Tensor</a> tensor = <a class="code hl_function" href="#a49f54c3a36e4b4d7756995c7211bc212">createTensor</a>(ctx, {256, 256}, <a class="code hl_enumvalue" href="#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">kf32</a>, data);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00513">513</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  514</span>                                        {</div>
<div class="line"><span class="lineno">  515</span>  <a class="code hl_struct" href="structgpu_1_1_tensor.html">Tensor</a> tensor =</div>
<div class="line"><span class="lineno">  516</span>      <a class="code hl_function" href="#a49f54c3a36e4b4d7756995c7211bc212">createTensor</a>(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6bf6ba07b846f568ccd0deebeacf258c">pool</a>, ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#ae810ad2a9cd07cd59e28a1da6965a7ba">device</a>, shape, dtype,</div>
<div class="line"><span class="lineno">  517</span>                   WGPUBufferUsage_Storage | WGPUBufferUsage_CopyDst |</div>
<div class="line"><span class="lineno">  518</span>                       WGPUBufferUsage_CopySrc);</div>
<div class="line"><span class="lineno">  519</span>  wgpuQueueWriteBuffer(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>, tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>, 0, data,</div>
<div class="line"><span class="lineno">  520</span>                       tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#a4dbb66b98ca78d85a755e11b3607c3e2">size</a>);</div>
<div class="line"><span class="lineno">  521</span>  <span class="keywordflow">return</span> tensor;</div>
<div class="line"><span class="lineno">  522</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a49f54c3a36e4b4d7756995c7211bc212" name="a49f54c3a36e4b4d7756995c7211bc212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f54c3a36e4b4d7756995c7211bc212">&#9670;&#160;</a></span>createTensor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a> gpu::createTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_tensor_pool.html">TensorPool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WGPUDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a></td>          <td class="paramname"><span class="paramname"><em>dtype</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WGPUBufferUsageFlags</td>          <td class="paramname"><span class="paramname"><em>usage</em></span><span class="paramdefsep"> = </span><span class="paramdefval">WGPUBufferUsage_Storage&#160;|&#160;WGPUBufferUsage_CopyDst&#160;|&#160;WGPUBufferUsage_CopySrc</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> factory function to create a tensor (a <a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> type is simply an <a class="el" href="structgpu_1_1_array.html" title="Represents a buffer of values on the GPU.">Array</a> with an N-dimensional <a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> specification) on the GPU. The tensor is created with the given shape, data type, and usage flags, added to the <a class="el" href="structgpu_1_1_tensor_pool.html" title="Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifeti...">TensorPool</a>, and returned. </p>
<p>This is the core implementation which takes the minimal set of parameters in terms of the raw WebGPU API, and is used by the other createTensor overloads which provide more ergonomic interfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td><a class="el" href="structgpu_1_1_tensor_pool.html" title="Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifeti...">TensorPool</a> instance to manage the tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>WGPUDevice instance to create the tensor on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td><a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> of the tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dtype</td><td>Data type of the tensor (e.g. kf32) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usage</td><td>Usage flags for the tensor buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance representing the created tensor</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgpu_1_1_tensor.html">Tensor</a> tensor = <a class="code hl_function" href="#a49f54c3a36e4b4d7756995c7211bc212">createTensor</a>(pool, device, {256, 256}, <a class="code hl_enumvalue" href="#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">kf32</a>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00448">448</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  452</span>                                                                   {</div>
<div class="line"><span class="lineno">  453</span>  <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kTrace, <span class="stringliteral">&quot;Creating tensor&quot;</span>);</div>
<div class="line"><span class="lineno">  454</span>  <span class="keywordtype">size_t</span> numElements = 1;</div>
<div class="line"><span class="lineno">  455</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> dim = 0; dim &lt; shape.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a>; dim++) {</div>
<div class="line"><span class="lineno">  456</span>    numElements *= shape.<a class="code hl_variable" href="structgpu_1_1_shape.html#a3f473a293f06b3b0b87e45f2ce707626">data</a>[dim];</div>
<div class="line"><span class="lineno">  457</span>  }</div>
<div class="line"><span class="lineno">  458</span>  <span class="keywordtype">size_t</span> size = dtype == kf32 ? <span class="keyword">sizeof</span>(float) * numElements : 0;</div>
<div class="line"><span class="lineno">  459</span>  WGPUBufferDescriptor bufferDesc = {</div>
<div class="line"><span class="lineno">  460</span>      .usage = usage,</div>
<div class="line"><span class="lineno">  461</span>      .size = size,</div>
<div class="line"><span class="lineno">  462</span>  };</div>
<div class="line"><span class="lineno">  463</span>  WGPUBuffer buffer = wgpuDeviceCreateBuffer(device, &amp;bufferDesc);</div>
<div class="line"><span class="lineno">  464</span>  pool.<a class="code hl_variable" href="structgpu_1_1_tensor_pool.html#a9ddc1ca280f17c2d4006c04617000c58">data</a>[buffer] = Tensor{</div>
<div class="line"><span class="lineno">  465</span>      .data = Array{.buffer = buffer, .usage = usage, .size = <a class="code hl_function" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a>},</div>
<div class="line"><span class="lineno">  466</span>      .shape = shape,</div>
<div class="line"><span class="lineno">  467</span>  };</div>
<div class="line"><span class="lineno">  468</span>  wgpuDeviceCreateBuffer(device, &amp;bufferDesc);</div>
<div class="line"><span class="lineno">  469</span>  <span class="keywordflow">return</span> pool.<a class="code hl_variable" href="structgpu_1_1_tensor_pool.html#a9ddc1ca280f17c2d4006c04617000c58">data</a>[buffer];</div>
<div class="line"><span class="lineno">  470</span>}</div>
<div class="ttc" id="anamespacegpu_html_ad0a150a30d8cb17db98e18ad6df0dcea"><div class="ttname"><a href="#ad0a150a30d8cb17db98e18ad6df0dcea">gpu::size</a></div><div class="ttdeci">size_t size(const Shape &amp;shape)</div><div class="ttdoc">Returns the number of elements in a tensor with the given shape, which is equal to the product of the...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00079">gpu.h:79</a></div></div>
<div class="ttc" id="astructgpu_1_1_shape_html_a3f473a293f06b3b0b87e45f2ce707626"><div class="ttname"><a href="structgpu_1_1_shape.html#a3f473a293f06b3b0b87e45f2ce707626">gpu::Shape::data</a></div><div class="ttdeci">std::array&lt; size_t, kMaxRank &gt; data</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00051">gpu.h:51</a></div></div>
<div class="ttc" id="astructgpu_1_1_tensor_pool_html_a9ddc1ca280f17c2d4006c04617000c58"><div class="ttname"><a href="structgpu_1_1_tensor_pool.html#a9ddc1ca280f17c2d4006c04617000c58">gpu::TensorPool::data</a></div><div class="ttdeci">std::unordered_map&lt; WGPUBuffer, Tensor &gt; data</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00178">gpu.h:178</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9d0086bd70e16a57ea98d068b7ab226" name="ad9d0086bd70e16a57ea98d068b7ab226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d0086bd70e16a57ea98d068b7ab226">&#9670;&#160;</a></span>dispatchKernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::dispatchKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>kernel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::promise&lt; void &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>promise</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously submits a kernel to the GPU queue for execution. It also sets up a callback to notify when the kernel has finished executing by setting the value of the promise in the kernel instance argument. </p>
<p>dispatchKernel does <em>not</em> wait for the kernel to finish executing and returns immediately. The caller can wait for the kernel to finish executing by calling <a class="el" href="#ae2d750e74781cee97de3145d9949b777">wait()</a> on the future in the kernel instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the kernel, from which the queue for the GPU is obtained </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td><a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> instance to dispatch</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ad9d0086bd70e16a57ea98d068b7ab226">dispatchKernel</a>(ctx, kernel);</div>
<div class="ttc" id="anamespacegpu_html_ad9d0086bd70e16a57ea98d068b7ab226"><div class="ttname"><a href="#ad9d0086bd70e16a57ea98d068b7ab226">gpu::dispatchKernel</a></div><div class="ttdeci">void dispatchKernel(Context &amp;ctx, Kernel &amp;kernel, std::promise&lt; void &gt; &amp;promise)</div><div class="ttdoc">Asynchronously submits a kernel to the GPU queue for execution. It also sets up a callback to notify ...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l01101">gpu.h:1101</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l01101">1101</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1102</span>                                                      {</div>
<div class="line"><span class="lineno"> 1103</span>  <span class="comment">// Submit the command buffer</span></div>
<div class="line"><span class="lineno"> 1104</span>  wgpuQueueSubmit(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>, 1, &amp;kernel.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a6216cca1a6525ef62ce02c56f86b1e36">commandBuffer</a>);</div>
<div class="line"><span class="lineno"> 1105</span>  wgpuQueueOnSubmittedWorkDone(</div>
<div class="line"><span class="lineno"> 1106</span>      ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>,</div>
<div class="line"><span class="lineno"> 1107</span>      [](WGPUQueueWorkDoneStatus status, <span class="keywordtype">void</span> *data) {</div>
<div class="line"><span class="lineno"> 1108</span>        check(status == WGPUQueueWorkDoneStatus_Success, <span class="stringliteral">&quot;Queue work done&quot;</span>,</div>
<div class="line"><span class="lineno"> 1109</span>              __FILE__, __LINE__);</div>
<div class="line"><span class="lineno"> 1110</span>        auto *promise = static_cast&lt;std::promise&lt;void&gt; *&gt;(data);</div>
<div class="line"><span class="lineno"> 1111</span>        promise-&gt;set_value();</div>
<div class="line"><span class="lineno"> 1112</span>      },</div>
<div class="line"><span class="lineno"> 1113</span>      &amp;promise);</div>
<div class="line"><span class="lineno"> 1114</span>}</div>
<div class="ttc" id="astructgpu_1_1_kernel_html_a6216cca1a6525ef62ce02c56f86b1e36"><div class="ttname"><a href="structgpu_1_1_kernel.html#a6216cca1a6525ef62ce02c56f86b1e36">gpu::Kernel::commandBuffer</a></div><div class="ttdeci">WGPUCommandBuffer commandBuffer</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00353">gpu.h:353</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a51976a8056f4e718ae36e5c256f58fc3" name="a51976a8056f4e718ae36e5c256f58fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51976a8056f4e718ae36e5c256f58fc3">&#9670;&#160;</a></span>eye()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::eye </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a square matrix with the identity matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to populate. </td></tr>
    <tr><td class="paramname">N</td><td>The number of rows and columns in the square matrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00232">232</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  232</span>                                    {</div>
<div class="line"><span class="lineno">  233</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; i++) {</div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; N; j++) {</div>
<div class="line"><span class="lineno">  235</span>      a[i * N + j] = (i == j) ? 1.0 : 0.0;</div>
<div class="line"><span class="lineno">  236</span>    }</div>
<div class="line"><span class="lineno">  237</span>  }</div>
<div class="line"><span class="lineno">  238</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae43fe29a6e3cdc14168666a7abfc3196" name="ae43fe29a6e3cdc14168666a7abfc3196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43fe29a6e3cdc14168666a7abfc3196">&#9670;&#160;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::flip </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>R</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>horizontal</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flip a matrix horizontally or vertically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The matrix to flip. </td></tr>
    <tr><td class="paramname">R</td><td>The number of rows in the matrix. </td></tr>
    <tr><td class="paramname">C</td><td>The number of columns in the matrix. </td></tr>
    <tr><td class="paramname">horizontal</td><td>Whether to flip horizontally (true) or vertically (false). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00265">265</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  265</span>                                                                       {</div>
<div class="line"><span class="lineno">  266</span>  <span class="keywordflow">if</span> (horizontal) {</div>
<div class="line"><span class="lineno">  267</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; R; i++) {</div>
<div class="line"><span class="lineno">  268</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; C / 2; j++) {</div>
<div class="line"><span class="lineno">  269</span>        std::swap(a[i * C + j], a[i * C + C - j - 1]);</div>
<div class="line"><span class="lineno">  270</span>      }</div>
<div class="line"><span class="lineno">  271</span>    }</div>
<div class="line"><span class="lineno">  272</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  273</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; R / 2; i++) {</div>
<div class="line"><span class="lineno">  274</span>      <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; C; j++) {</div>
<div class="line"><span class="lineno">  275</span>        std::swap(a[i * C + j], a[(R - i - 1) * C + j]);</div>
<div class="line"><span class="lineno">  276</span>      }</div>
<div class="line"><span class="lineno">  277</span>    }</div>
<div class="line"><span class="lineno">  278</span>  }</div>
<div class="line"><span class="lineno">  279</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b6ed2e0cf0953575f225df1ecac2970" name="a2b6ed2e0cf0953575f225df1ecac2970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6ed2e0cf0953575f225df1ecac2970">&#9670;&#160;</a></span>FreeTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::FreeTensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_tensor_pool.html">TensorPool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pool</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a></td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a tensor resource and updates the tensor pool. </p>
<p>Only needed if the use case requires manually managing resource lifetimes of GPU tensors. For simple use cases, the <a class="el" href="structgpu_1_1_tensor_pool.html" title="Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifeti...">TensorPool</a> destructor will automatically free all tensors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pool</td><td><a class="el" href="structgpu_1_1_tensor_pool.html" title="Represents a pool of tensors to manage GPU resources. The pool is responsible for managing the lifeti...">TensorPool</a> instance to manage the tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance to free</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a2b6ed2e0cf0953575f225df1ecac2970">FreeTensor</a>(pool, tensor);</div>
<div class="ttc" id="anamespacegpu_html_a2b6ed2e0cf0953575f225df1ecac2970"><div class="ttname"><a href="#a2b6ed2e0cf0953575f225df1ecac2970">gpu::FreeTensor</a></div><div class="ttdeci">void FreeTensor(TensorPool &amp;pool, Tensor tensor)</div><div class="ttdoc">Frees a tensor resource and updates the tensor pool.</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00538">gpu.h:538</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00538">538</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  538</span>                                                        {</div>
<div class="line"><span class="lineno">  539</span>  <span class="keywordflow">if</span> (tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>) {</div>
<div class="line"><span class="lineno">  540</span>    wgpuBufferRelease(tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>);</div>
<div class="line"><span class="lineno">  541</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  542</span>    LOG(kDefLog, kWarn, <span class="stringliteral">&quot;Tried to free tensor with null buffer&quot;</span>);</div>
<div class="line"><span class="lineno">  543</span>  }</div>
<div class="line"><span class="lineno">  544</span>  <span class="keywordflow">if</span> (pool.<a class="code hl_variable" href="structgpu_1_1_tensor_pool.html#a9ddc1ca280f17c2d4006c04617000c58">data</a>.find(tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>) != pool.<a class="code hl_variable" href="structgpu_1_1_tensor_pool.html#a9ddc1ca280f17c2d4006c04617000c58">data</a>.end()) {</div>
<div class="line"><span class="lineno">  545</span>    pool.<a class="code hl_variable" href="structgpu_1_1_tensor_pool.html#a9ddc1ca280f17c2d4006c04617000c58">data</a>.erase(tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>);</div>
<div class="line"><span class="lineno">  546</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  547</span>    <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kWarn, <span class="stringliteral">&quot;Tried to free tensor that was not in pool&quot;</span>);</div>
<div class="line"><span class="lineno">  548</span>  }</div>
<div class="line"><span class="lineno">  549</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a69f10f29c89d81fc5358ea9485ee6fa3" name="a69f10f29c89d81fc5358ea9485ee6fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f10f29c89d81fc5358ea9485ee6fa3">&#9670;&#160;</a></span>isclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpu::isclose </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1e-3</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the values of two arrays are close to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first array. </td></tr>
    <tr><td class="paramname">b</td><td>The second array. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the arrays. </td></tr>
    <tr><td class="paramname">tol</td><td>The tolerance for closeness. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the arrays are close, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00289">289</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  289</span>                                                             {</div>
<div class="line"><span class="lineno">  290</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; i++) {</div>
<div class="line"><span class="lineno">  291</span>    <span class="keywordflow">if</span> (std::abs(a[i] - b[i]) &gt; tol || std::isnan(a[i]) || std::isnan(b[i])) {</div>
<div class="line"><span class="lineno">  292</span>      <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kError, <span class="stringliteral">&quot;Mismatch at index %d: %f != %f&quot;</span>, i, a[i], b[i]);</div>
<div class="line"><span class="lineno">  293</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  294</span>    }</div>
<div class="line"><span class="lineno">  295</span>  }</div>
<div class="line"><span class="lineno">  296</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  297</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a508fff3f15882a37b1c0bd0341296176" name="a508fff3f15882a37b1c0bd0341296176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508fff3f15882a37b1c0bd0341296176">&#9670;&#160;</a></span>LOG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::LOG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_logger.html">Logger</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>logger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log a message to the logger. If NDEBUG is defined in a source or as a compiler flag, this is a no-op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>The logger to log to. </td></tr>
    <tr><td class="paramname">level</td><td>The log level of the message. </td></tr>
    <tr><td class="paramname">message</td><td>The message to log. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="logging_8h_source.html#l00034">34</a> of file <a class="el" href="logging_8h_source.html">logging.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   34</span>                                                                     {</div>
<div class="line"><span class="lineno">   35</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *orange = <span class="stringliteral">&quot;\033[0;33m&quot;</span>;</div>
<div class="line"><span class="lineno">   36</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *red = <span class="stringliteral">&quot;\033[0;31m&quot;</span>;</div>
<div class="line"><span class="lineno">   37</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *white = <span class="stringliteral">&quot;\033[0;37m&quot;</span>;</div>
<div class="line"><span class="lineno">   38</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *gray = <span class="stringliteral">&quot;\033[0;90m&quot;</span>;</div>
<div class="line"><span class="lineno">   39</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *reset = <span class="stringliteral">&quot;\033[0m&quot;</span>;</div>
<div class="line"><span class="lineno">   40</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *logColors[] = {red, red, orange, gray};</div>
<div class="line"><span class="lineno">   41</span>  <span class="keywordflow">if</span> (level &lt;= logger.<a class="code hl_variable" href="structgpu_1_1_logger.html#acfa09841298ff5ddfb50fece65cb3561">level</a>) {</div>
<div class="line"><span class="lineno">   42</span>    va_list(args);</div>
<div class="line"><span class="lineno">   43</span>    va_start(args, message);</div>
<div class="line"><span class="lineno">   44</span>    snprintf(logger.<a class="code hl_variable" href="structgpu_1_1_logger.html#aff6d34b61575cfd965db61ff1acb607a">buffer</a>, <span class="keyword">sizeof</span>(logger.<a class="code hl_variable" href="structgpu_1_1_logger.html#aff6d34b61575cfd965db61ff1acb607a">buffer</a>), message, args);</div>
<div class="line"><span class="lineno">   45</span>    <span class="comment">// Brackets and messages are white.</span></div>
<div class="line"><span class="lineno">   46</span>    <span class="comment">// Log levels are red for error and warning, orange for info, and grey for trace.</span></div>
<div class="line"><span class="lineno">   47</span>    <span class="comment">// Then the color is reset.</span></div>
<div class="line"><span class="lineno">   48</span>    fprintf(logger.<a class="code hl_variable" href="structgpu_1_1_logger.html#a84b5eb796e90dc1e55ecfa798327786e">stream</a>, <span class="stringliteral">&quot;%s[%s%s%s] &quot;</span>, white, logColors[level], kLevelStr[level],</div>
<div class="line"><span class="lineno">   49</span>            white);</div>
<div class="line"><span class="lineno">   50</span>    vfprintf(logger.<a class="code hl_variable" href="structgpu_1_1_logger.html#a84b5eb796e90dc1e55ecfa798327786e">stream</a>, message, args);</div>
<div class="line"><span class="lineno">   51</span>    fprintf(logger.<a class="code hl_variable" href="structgpu_1_1_logger.html#a84b5eb796e90dc1e55ecfa798327786e">stream</a>, <span class="stringliteral">&quot;%s\n&quot;</span>, reset);</div>
<div class="line"><span class="lineno">   52</span>    va_end(args);</div>
<div class="line"><span class="lineno">   53</span>  }</div>
<div class="line"><span class="lineno">   54</span>}</div>
<div class="ttc" id="astructgpu_1_1_logger_html_a84b5eb796e90dc1e55ecfa798327786e"><div class="ttname"><a href="structgpu_1_1_logger.html#a84b5eb796e90dc1e55ecfa798327786e">gpu::Logger::stream</a></div><div class="ttdeci">FILE * stream</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00020">logging.h:20</a></div></div>
<div class="ttc" id="astructgpu_1_1_logger_html_acfa09841298ff5ddfb50fece65cb3561"><div class="ttname"><a href="structgpu_1_1_logger.html#acfa09841298ff5ddfb50fece65cb3561">gpu::Logger::level</a></div><div class="ttdeci">int level</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00022">logging.h:22</a></div></div>
<div class="ttc" id="astructgpu_1_1_logger_html_aff6d34b61575cfd965db61ff1acb607a"><div class="ttname"><a href="structgpu_1_1_logger.html#aff6d34b61575cfd965db61ff1acb607a">gpu::Logger::buffer</a></div><div class="ttdeci">char buffer[1024]</div><div class="ttdef"><b>Definition</b> <a href="logging_8h_source.html#l00021">logging.h:21</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abd91fae4ecbe9c19d23ac0e6f59efdaa" name="abd91fae4ecbe9c19d23ac0e6f59efdaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd91fae4ecbe9c19d23ac0e6f59efdaa">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gpu::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator implementation to make the <a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> type hashable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>First <a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> instance to compare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Second <a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> instance to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if lhs &lt; rhs, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00362">362</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  362</span>                                                            {</div>
<div class="line"><span class="lineno">  363</span>  <span class="keywordflow">return</span> lhs.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a6216cca1a6525ef62ce02c56f86b1e36">commandBuffer</a> &lt; rhs.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a6216cca1a6525ef62ce02c56f86b1e36">commandBuffer</a>;</div>
<div class="line"><span class="lineno">  364</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a958ba3c82efaee6749be9f5b828027db" name="a958ba3c82efaee6749be9f5b828027db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958ba3c82efaee6749be9f5b828027db">&#9670;&#160;</a></span>randint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::randint </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the array with random integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to populate. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramname">gen</td><td>The random number generator. </td></tr>
    <tr><td class="paramname">min</td><td>The minimum value for the random integers. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum value for the random integers. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00172">172</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  172</span>                                                                             {</div>
<div class="line"><span class="lineno">  173</span>  std::uniform_int_distribution&lt;&gt; dist(min, max);</div>
<div class="line"><span class="lineno">  174</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; i++) {</div>
<div class="line"><span class="lineno">  175</span>    a[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(dist(gen));</div>
<div class="line"><span class="lineno">  176</span>  }</div>
<div class="line"><span class="lineno">  177</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a331ec9b4ea7d787eae6994c5ae7d32d2" name="a331ec9b4ea7d787eae6994c5ae7d32d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331ec9b4ea7d787eae6994c5ae7d32d2">&#9670;&#160;</a></span>randint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename numtype , size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gpu::randint </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; numtype, <a class="el" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <code><a class="el" href="#a958ba3c82efaee6749be9f5b828027db" title="Populate the array with random integers.">randint()</a></code> for std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to populate. </td></tr>
    <tr><td class="paramname">gen</td><td>The random number generator. </td></tr>
    <tr><td class="paramname">min</td><td>The minimum value for the random integers. </td></tr>
    <tr><td class="paramname">max</td><td>The maximum value for the random integers. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00187">187</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  188</span>                          {</div>
<div class="line"><span class="lineno">  189</span>  std::uniform_int_distribution&lt;&gt; dist(min, max);</div>
<div class="line"><span class="lineno">  190</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_function" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a>; i++) {</div>
<div class="line"><span class="lineno">  191</span>    a[i] = <span class="keyword">static_cast&lt;</span>numtype<span class="keyword">&gt;</span>(dist(gen));</div>
<div class="line"><span class="lineno">  192</span>  }</div>
<div class="line"><span class="lineno">  193</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a64154e5de68ac36383b7bfb8a5dfc57f" name="a64154e5de68ac36383b7bfb8a5dfc57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64154e5de68ac36383b7bfb8a5dfc57f">&#9670;&#160;</a></span>randn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::randn </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>mean</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>std</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the array with random floats, generated from a Gaussian distribution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to populate. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramname">gen</td><td>The random number generator. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean of the Gaussian distribution. </td></tr>
    <tr><td class="paramname">std</td><td>The standard deviation of the Gaussian distribution. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00203">203</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  204</span>                            {</div>
<div class="line"><span class="lineno">  205</span>  std::normal_distribution&lt;float&gt; dist(mean, std);</div>
<div class="line"><span class="lineno">  206</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; i++) {</div>
<div class="line"><span class="lineno">  207</span>    a[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(dist(gen));</div>
<div class="line"><span class="lineno">  208</span>  }</div>
<div class="line"><span class="lineno">  209</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d0d0e6da05536cf06dd497542bff379" name="a4d0d0e6da05536cf06dd497542bff379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0d0e6da05536cf06dd497542bff379">&#9670;&#160;</a></span>randn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gpu::randn </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; float, <a class="el" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mt19937 &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>mean</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>std</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <code><a class="el" href="#a64154e5de68ac36383b7bfb8a5dfc57f" title="Populate the array with random floats, generated from a Gaussian distribution.">randn()</a></code> for std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to populate. </td></tr>
    <tr><td class="paramname">gen</td><td>The random number generator. </td></tr>
    <tr><td class="paramname">mean</td><td>The mean of the Gaussian distribution. </td></tr>
    <tr><td class="paramname">std</td><td>The standard deviation of the Gaussian distribution. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00219">219</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  220</span>                            {</div>
<div class="line"><span class="lineno">  221</span>  std::normal_distribution&lt;float&gt; dist(mean, std);</div>
<div class="line"><span class="lineno">  222</span>  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code hl_function" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a>; i++) {</div>
<div class="line"><span class="lineno">  223</span>    a[i] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(dist(gen));</div>
<div class="line"><span class="lineno">  224</span>  }</div>
<div class="line"><span class="lineno">  225</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4dfc7beab528e65823ed28d9095149db" name="a4dfc7beab528e65823ed28d9095149db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dfc7beab528e65823ed28d9095149db">&#9670;&#160;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::range </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the array with a range of values. This is mostly for testing purposes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to populate. </td></tr>
    <tr><td class="paramname">N</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramname">start</td><td>The starting value. </td></tr>
    <tr><td class="paramname">step</td><td>The step size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00140">140</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  140</span>                                                                        {</div>
<div class="line"><span class="lineno">  141</span>  <span class="comment">// TODO(avh): currently unused - check</span></div>
<div class="line"><span class="lineno">  142</span>  <span class="keywordtype">float</span> curr = start;</div>
<div class="line"><span class="lineno">  143</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; N; i++) {</div>
<div class="line"><span class="lineno">  144</span>    input[i] = curr;</div>
<div class="line"><span class="lineno">  145</span>    curr += step;</div>
<div class="line"><span class="lineno">  146</span>  }</div>
<div class="line"><span class="lineno">  147</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3990d3a9153396be1f532601bb8d1da0" name="a3990d3a9153396be1f532601bb8d1da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3990d3a9153396be1f532601bb8d1da0">&#9670;&#160;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gpu::range </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; float, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>start</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>step</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <code><a class="el" href="#a4dfc7beab528e65823ed28d9095149db" title="Populate the array with a range of values. This is mostly for testing purposes.">range()</a></code> for std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The array to populate. </td></tr>
    <tr><td class="paramname">start</td><td>The starting value. </td></tr>
    <tr><td class="paramname">step</td><td>The step size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00156">156</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  156</span>                                                                           {</div>
<div class="line"><span class="lineno">  157</span>  <span class="keywordtype">float</span> curr = start;</div>
<div class="line"><span class="lineno">  158</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = start; i &lt; N; i++) {</div>
<div class="line"><span class="lineno">  159</span>    input[i] = curr;</div>
<div class="line"><span class="lineno">  160</span>    curr += step;</div>
<div class="line"><span class="lineno">  161</span>  }</div>
<div class="line"><span class="lineno">  162</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f58428241e500f69c95422e678ac2f0" name="a9f58428241e500f69c95422e678ac2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f58428241e500f69c95422e678ac2f0">&#9670;&#160;</a></span>replaceAll() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::replaceAll </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>to</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simple in-place string replacement helper function for substituting placeholders in a WGSL string template. </p>
<p>Note this is not meant to be used in performance-critical code paths and should be used ahead-of-time before any performance-critical codepath to preprocess WGSL code strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to mutate with substitution replacements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>Substring to replace </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>Substring to replace with</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a9f58428241e500f69c95422e678ac2f0">replaceAll</a>(str, <span class="stringliteral">&quot;{{workgroupSize}}&quot;</span>, <span class="stringliteral">&quot;256&quot;</span>);</div>
<div class="ttc" id="anamespacegpu_html_a9f58428241e500f69c95422e678ac2f0"><div class="ttname"><a href="#a9f58428241e500f69c95422e678ac2f0">gpu::replaceAll</a></div><div class="ttdeci">void replaceAll(std::string &amp;str, const std::string &amp;from, const std::string &amp;to)</div><div class="ttdoc">simple in-place string replacement helper function for substituting placeholders in a WGSL string tem...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00235">gpu.h:235</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00235">235</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  236</span>                                            {</div>
<div class="line"><span class="lineno">  237</span>  <span class="keywordtype">size_t</span> start_pos = 0;</div>
<div class="line"><span class="lineno">  238</span>  <span class="keywordflow">while</span> ((start_pos = str.find(from, start_pos)) != std::string::npos) {</div>
<div class="line"><span class="lineno">  239</span>    str.replace(start_pos, from.length(), to);</div>
<div class="line"><span class="lineno">  240</span>    start_pos += to.length();</div>
<div class="line"><span class="lineno">  241</span>  }</div>
<div class="line"><span class="lineno">  242</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8054277aecd35b5d61ac5ce150aa6c22" name="a8054277aecd35b5d61ac5ce150aa6c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8054277aecd35b5d61ac5ce150aa6c22">&#9670;&#160;</a></span>replaceAll() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::replaceAll </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the string replacement helper function to replace multiple substrings in a string with multiple replacements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to mutate with substitution replacements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reps</td><td>Vector of pairs of substrings to replace and their replacements.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a9f58428241e500f69c95422e678ac2f0">replaceAll</a>(str, {{<span class="stringliteral">&quot;{{workgroupSize}}&quot;</span>, <span class="stringliteral">&quot;256&quot;</span>}, {<span class="stringliteral">&quot;{{precision}}&quot;</span>,</div>
</div><!-- fragment --><p> "f32"}}); </p>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00321">321</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  322</span>                                                                             {</div>
<div class="line"><span class="lineno">  323</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;rep : reps) {</div>
<div class="line"><span class="lineno">  324</span>    <a class="code hl_function" href="#a9f58428241e500f69c95422e678ac2f0">replaceAll</a>(str, rep.first, rep.second);</div>
<div class="line"><span class="lineno">  325</span>  }</div>
<div class="line"><span class="lineno">  326</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac59323bc390c2a01dc473dcb72d03868" name="ac59323bc390c2a01dc473dcb72d03868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59323bc390c2a01dc473dcb72d03868">&#9670;&#160;</a></span>resetCommandBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::resetCommandBuffer </td>
          <td>(</td>
          <td class="paramtype">WGPUDevice &amp;</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the command buffer in preparation for a kernel dispatch. Since command buffers are consumed upon submission, this function is used both in the initial kernel creation and every time the kernel is to be reused for a dispatch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>WGPUDevice instance to manage the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td><a class="el" href="structgpu_1_1_kernel.html" title="Represents handles + metadata for a reusable kernel on the GPU. The struct members can be divided int...">Kernel</a> instance representing the kernel to reset</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ac59323bc390c2a01dc473dcb72d03868">resetCommandBuffer</a>(device, op);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00840">840</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  840</span>                                                               {</div>
<div class="line"><span class="lineno">  841</span>  {</div>
<div class="line"><span class="lineno">  842</span>    WGPUCommandEncoder commandEncoder =</div>
<div class="line"><span class="lineno">  843</span>        wgpuDeviceCreateCommandEncoder(device, <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  844</span>    WGPUComputePassEncoder computePassEncoder =</div>
<div class="line"><span class="lineno">  845</span>        wgpuCommandEncoderBeginComputePass(commandEncoder, <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  846</span>    wgpuComputePassEncoderSetPipeline(computePassEncoder, op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aa8aaca0b5f23c2991b0d74fa6cfd1967">computePipeline</a>);</div>
<div class="line"><span class="lineno">  847</span>    wgpuComputePassEncoderSetBindGroup(computePassEncoder, 0, op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#ab3c829286d3d649f9d6888288f132e41">bindGroup</a>, 0,</div>
<div class="line"><span class="lineno">  848</span>                                       <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  849</span>    wgpuComputePassEncoderDispatchWorkgroups(</div>
<div class="line"><span class="lineno">  850</span>        computePassEncoder, op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aec962f96d74dd1f3144c138030b14446">nWorkgroups</a>[0], op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aec962f96d74dd1f3144c138030b14446">nWorkgroups</a>[1],</div>
<div class="line"><span class="lineno">  851</span>        op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aec962f96d74dd1f3144c138030b14446">nWorkgroups</a>[2]);</div>
<div class="line"><span class="lineno">  852</span>    wgpuComputePassEncoderEnd(computePassEncoder);</div>
<div class="line"><span class="lineno">  853</span>    op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a6216cca1a6525ef62ce02c56f86b1e36">commandBuffer</a> = wgpuCommandEncoderFinish(commandEncoder, <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  854</span>  }</div>
<div class="line"><span class="lineno">  855</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a70a38bd3469ce5a2c7be8891f499bb24" name="a70a38bd3469ce5a2c7be8891f499bb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a38bd3469ce5a2c7be8891f499bb24">&#9670;&#160;</a></span>show() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename numtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string gpu::show </td>
          <td>(</td>
          <td class="paramtype">const numtype *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Show a 2D array as a string, base implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numtype</td><td>The type of the array elements. Must be int or float. </td></tr>
    <tr><td class="paramname">a</td><td>The array to show. </td></tr>
    <tr><td class="paramname">rows</td><td>The number of rows in the array. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns in the array. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the array to show. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The string representation of the array. <div class="fragment"><div class="line">std::array&lt;float, 4&gt; a = {1.0, 2.0, 3.0, 4.0};</div>
<div class="line">printf(<span class="stringliteral">&quot;%s&quot;</span>, <a class="code hl_function" href="#a70a38bd3469ce5a2c7be8891f499bb24">show&lt;float&gt;</a>(a.data(), 2, 2, <span class="stringliteral">&quot;a&quot;</span>).c_str());</div>
<div class="ttc" id="anamespacegpu_html_a70a38bd3469ce5a2c7be8891f499bb24"><div class="ttname"><a href="#a70a38bd3469ce5a2c7be8891f499bb24">gpu::show</a></div><div class="ttdeci">std::string show(const numtype *a, size_t rows, size_t cols, const std::string &amp;name=&quot;&quot;)</div><div class="ttdoc">Show a 2D array as a string, base implementation.</div><div class="ttdef"><b>Definition</b> <a href="array__utils_8h_source.html#l00044">array_utils.h:44</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00044">44</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   45</span>                                             {</div>
<div class="line"><span class="lineno">   46</span>  std::string output = <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">   47</span>  <span class="keywordflow">if</span> (name != <span class="stringliteral">&quot;&quot;</span>) {</div>
<div class="line"><span class="lineno">   48</span>    output += <span class="stringliteral">&quot;\n&quot;</span> + name + <span class="stringliteral">&quot; (&quot;</span> + std::to_string(rows) + <span class="stringliteral">&quot;, &quot;</span> +</div>
<div class="line"><span class="lineno">   49</span>              std::to_string(cols) + <span class="stringliteral">&quot;)\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">   50</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">   51</span>    output +=</div>
<div class="line"><span class="lineno">   52</span>        <span class="stringliteral">&quot;\n(&quot;</span> + std::to_string(rows) + <span class="stringliteral">&quot;, &quot;</span> + std::to_string(cols) + <span class="stringliteral">&quot;)\n\n&quot;</span>;</div>
<div class="line"><span class="lineno">   53</span>  }</div>
<div class="line"><span class="lineno">   54</span>  <span class="comment">// spacing as log10 of max value</span></div>
<div class="line"><span class="lineno">   55</span>  <span class="keywordtype">int</span> spacing = 1;</div>
<div class="line"><span class="lineno">   56</span>  numtype max = *std::max_element(a, a + rows * cols);</div>
<div class="line"><span class="lineno">   57</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same&lt;numtype, int&gt;::value) {</div>
<div class="line"><span class="lineno">   58</span>    spacing = std::max(0, (<span class="keywordtype">int</span>)log10(max + .01)) + 2;</div>
<div class="line"><span class="lineno">   59</span>  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same&lt;numtype, float&gt;::value) {</div>
<div class="line"><span class="lineno">   60</span>    <span class="comment">// spacing = std::max(0, (int)log10(max + .01)) + 1;</span></div>
<div class="line"><span class="lineno">   61</span>    spacing = 8; <span class="comment">// scientific notation</span></div>
<div class="line"><span class="lineno">   62</span>  } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">   63</span>    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unsupported number type for show()&quot;</span>);</div>
<div class="line"><span class="lineno">   64</span>  }</div>
<div class="line"><span class="lineno">   65</span>  <span class="comment">// print to stdout line break for each row</span></div>
<div class="line"><span class="lineno">   66</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; rows; i++) {</div>
<div class="line"><span class="lineno">   67</span>    <span class="keywordflow">if</span> (i == kShowMaxRows / 2 &amp;&amp; rows &gt; kShowMaxRows) {</div>
<div class="line"><span class="lineno">   68</span>      output += <span class="stringliteral">&quot;...\n&quot;</span>;</div>
<div class="line"><span class="lineno">   69</span>      i = rows - <a class="code hl_variable" href="#add001dc6cf01bdd72293694791d5d1bc">kShowMaxRows</a> / 2;</div>
<div class="line"><span class="lineno">   70</span>    }</div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; cols; j++) {</div>
<div class="line"><span class="lineno">   72</span>      <span class="keywordflow">if</span> (j == kShowMaxCols / 2 &amp;&amp; cols &gt; kShowMaxCols) {</div>
<div class="line"><span class="lineno">   73</span>        output += <span class="stringliteral">&quot; ..&quot;</span>;</div>
<div class="line"><span class="lineno">   74</span>        j = cols - <a class="code hl_variable" href="#aba79867fea95e4073373d7618094a9cd">kShowMaxCols</a> / 2;</div>
<div class="line"><span class="lineno">   75</span>      }</div>
<div class="line"><span class="lineno">   76</span>      <span class="keywordtype">char</span> buffer[50];</div>
<div class="line"><span class="lineno">   77</span>      <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same&lt;numtype, int&gt;::value) {</div>
<div class="line"><span class="lineno">   78</span>        sprintf(buffer, <span class="stringliteral">&quot;%*d&quot;</span>, spacing, a[i * cols + j]);</div>
<div class="line"><span class="lineno">   79</span>      } <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same&lt;numtype, float&gt;::value) {</div>
<div class="line"><span class="lineno">   80</span>        <span class="keywordflow">if</span> (std::abs(a[i * cols + j]) &lt; 1000 &amp;&amp;</div>
<div class="line"><span class="lineno">   81</span>                std::abs(a[i * cols + j]) &gt; 0.01 ||</div>
<div class="line"><span class="lineno">   82</span>            a[i * cols + j] == 0.0) {</div>
<div class="line"><span class="lineno">   83</span>          sprintf(buffer, <span class="stringliteral">&quot;%9.2f&quot;</span>, a[i * cols + j]);</div>
<div class="line"><span class="lineno">   84</span>        } <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   85</span>          sprintf(buffer, <span class="stringliteral">&quot;%10.2e&quot;</span>, a[i * cols + j]);</div>
<div class="line"><span class="lineno">   86</span>      } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">   87</span>        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Unsupported number type for show()&quot;</span>);</div>
<div class="line"><span class="lineno">   88</span>      }</div>
<div class="line"><span class="lineno">   89</span>      output += buffer;</div>
<div class="line"><span class="lineno">   90</span>    }</div>
<div class="line"><span class="lineno">   91</span>    output += <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">   92</span>  }</div>
<div class="line"><span class="lineno">   93</span>  output += <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">   94</span>  <span class="keywordflow">return</span> output;</div>
<div class="line"><span class="lineno">   95</span>}</div>
<div class="ttc" id="anamespacegpu_html_aba79867fea95e4073373d7618094a9cd"><div class="ttname"><a href="#aba79867fea95e4073373d7618094a9cd">gpu::kShowMaxCols</a></div><div class="ttdeci">static constexpr int kShowMaxCols</div><div class="ttdef"><b>Definition</b> <a href="array__utils_8h_source.html#l00027">array_utils.h:27</a></div></div>
<div class="ttc" id="anamespacegpu_html_add001dc6cf01bdd72293694791d5d1bc"><div class="ttname"><a href="#add001dc6cf01bdd72293694791d5d1bc">gpu::kShowMaxRows</a></div><div class="ttdeci">static constexpr int kShowMaxRows</div><div class="ttdef"><b>Definition</b> <a href="array__utils_8h_source.html#l00026">array_utils.h:26</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a558085d4f4bdbc85d9d894c05e8c79e0" name="a558085d4f4bdbc85d9d894c05e8c79e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558085d4f4bdbc85d9d894c05e8c79e0">&#9670;&#160;</a></span>show() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t rows, size_t cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string gpu::show </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; float, rows *cols &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <code><a class="el" href="#a70a38bd3469ce5a2c7be8891f499bb24" title="Show a 2D array as a string, base implementation.">show()</a></code> for float std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to show. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The string representation of the array.</dd></dl>
<div class="fragment"><div class="line">std::array&lt;float, 4&gt; a = {1.0, 2.0, 3.0, 4.0};</div>
<div class="line">printf(<span class="stringliteral">&quot;%s&quot;</span>, <a class="code hl_function" href="#a70a38bd3469ce5a2c7be8891f499bb24">show</a>(a, <span class="stringliteral">&quot;a&quot;</span>).c_str());</div>
</div><!-- fragment --><p> @ <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00127">127</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  128</span>                                             {</div>
<div class="line"><span class="lineno">  129</span>  <span class="keywordflow">return</span> show&lt;float, rows, cols&gt;(a, name);</div>
<div class="line"><span class="lineno">  130</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a7b41f8fbb4b127d4c43b494bf9d950" name="a6a7b41f8fbb4b127d4c43b494bf9d950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7b41f8fbb4b127d4c43b494bf9d950">&#9670;&#160;</a></span>show() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename numtype , size_t rows, size_t cols&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string gpu::show </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; numtype, rows *cols &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of <code><a class="el" href="#a70a38bd3469ce5a2c7be8891f499bb24" title="Show a 2D array as a string, base implementation.">show()</a></code> for std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numtype</td><td>The type of the array elements. Must be int or float. </td></tr>
    <tr><td class="paramname">a</td><td>The array to show. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the array to show. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::string The string representation of the array. <div class="fragment"><div class="line">std::array&lt;float, 4&gt; a = {1.0, 2.0, 3.0, 4.0};</div>
<div class="line">printf(<span class="stringliteral">&quot;%s&quot;</span>, <a class="code hl_function" href="#a70a38bd3469ce5a2c7be8891f499bb24">show&lt;float&gt;</a>(a, <span class="stringliteral">&quot;a&quot;</span>).c_str());</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00110">110</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  111</span>                                             {</div>
<div class="line"><span class="lineno">  112</span>  <span class="keywordflow">return</span> show&lt;numtype&gt;(a.data(), rows, cols, name);</div>
<div class="line"><span class="lineno">  113</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0a150a30d8cb17db98e18ad6df0dcea" name="ad0a150a30d8cb17db98e18ad6df0dcea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a150a30d8cb17db98e18ad6df0dcea">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gpu::size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in a tensor with the given shape, which is equal to the product of the dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td><a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> of the tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements in the tensor</dd></dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a>({256, 256}) -&gt; 65536</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00079">79</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   79</span>                                       {</div>
<div class="line"><span class="lineno">   80</span>  <span class="keywordtype">size_t</span> numels = 1;</div>
<div class="line"><span class="lineno">   81</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; shape.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a>; i++) {</div>
<div class="line"><span class="lineno">   82</span>    numels *= shape.<a class="code hl_variable" href="structgpu_1_1_shape.html#a3f473a293f06b3b0b87e45f2ce707626">data</a>[i];</div>
<div class="line"><span class="lineno">   83</span>  }</div>
<div class="line"><span class="lineno">   84</span>  <span class="keywordflow">return</span> numels;</div>
<div class="line"><span class="lineno">   85</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8512ee079905e5861ab90064caefc299" name="a8512ee079905e5861ab90064caefc299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8512ee079905e5861ab90064caefc299">&#9670;&#160;</a></span>toCPU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::toCPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from a GPU buffer to CPU memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance representing the GPU buffer to copy from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to the CPU memory to copy the data to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Size of the data buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a8512ee079905e5861ab90064caefc299">toCPU</a>(ctx, tensor, data, bufferSize);</div>
<div class="ttc" id="anamespacegpu_html_a8512ee079905e5861ab90064caefc299"><div class="ttname"><a href="#a8512ee079905e5861ab90064caefc299">gpu::toCPU</a></div><div class="ttdeci">void toCPU(Context &amp;ctx, Tensor &amp;tensor, float *data, size_t bufferSize)</div><div class="ttdoc">Copies data from a GPU buffer to CPU memory.</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00707">gpu.h:707</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00707">707</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  708</span>                                     {</div>
<div class="line"><span class="lineno">  709</span>  WGPUDevice device = ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#ae810ad2a9cd07cd59e28a1da6965a7ba">device</a>;</div>
<div class="line"><span class="lineno">  710</span>  <span class="keyword">struct </span>CopyOp {</div>
<div class="line"><span class="lineno">  711</span>    WGPUCommandBuffer commandBuffer;</div>
<div class="line"><span class="lineno">  712</span>    WGPUBuffer readbackBuffer;</div>
<div class="line"><span class="lineno">  713</span>    std::promise&lt;void&gt; promise;</div>
<div class="line"><span class="lineno">  714</span>    std::future&lt;void&gt; future;</div>
<div class="line"><span class="lineno">  715</span>    <a class="code hl_struct" href="structgpu_1_1_callback_data_dyn.html">CallbackDataDyn</a> callbackData;</div>
<div class="line"><span class="lineno">  716</span>  };</div>
<div class="line"><span class="lineno">  717</span>  CopyOp op;</div>
<div class="line"><span class="lineno">  718</span>  op.future = op.promise.get_future();</div>
<div class="line"><span class="lineno">  719</span>  {</div>
<div class="line"><span class="lineno">  720</span>    WGPUBufferDescriptor readbackBufferDescriptor = {</div>
<div class="line"><span class="lineno">  721</span>        .usage = WGPUBufferUsage_CopyDst | WGPUBufferUsage_MapRead,</div>
<div class="line"><span class="lineno">  722</span>        .size = bufferSize,</div>
<div class="line"><span class="lineno">  723</span>    };</div>
<div class="line"><span class="lineno">  724</span>    op.readbackBuffer =</div>
<div class="line"><span class="lineno">  725</span>        wgpuDeviceCreateBuffer(device, &amp;readbackBufferDescriptor);</div>
<div class="line"><span class="lineno">  726</span>  }</div>
<div class="line"><span class="lineno">  727</span>  {</div>
<div class="line"><span class="lineno">  728</span>    WGPUCommandEncoder commandEncoder;</div>
<div class="line"><span class="lineno">  729</span>    WGPUComputePassEncoder computePassEncoder;</div>
<div class="line"><span class="lineno">  730</span>    commandEncoder = wgpuDeviceCreateCommandEncoder(device, <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  731</span>    wgpuCommandEncoderCopyBufferToBuffer(commandEncoder, tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>, 0,</div>
<div class="line"><span class="lineno">  732</span>                                         op.readbackBuffer, 0, bufferSize);</div>
<div class="line"><span class="lineno">  733</span>    op.commandBuffer = wgpuCommandEncoderFinish(commandEncoder, <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="lineno">  734</span>    <a class="code hl_function" href="#a3e8bcb1dd85ad12c99d6f27ace6d891a">check</a>(op.commandBuffer, <span class="stringliteral">&quot;Create command buffer&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"><span class="lineno">  735</span>  }</div>
<div class="line"><span class="lineno">  736</span>  wgpuQueueSubmit(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>, 1, &amp;op.commandBuffer);</div>
<div class="line"><span class="lineno">  737</span>  CallbackDataDyn callbackData = {op.readbackBuffer, bufferSize, data,</div>
<div class="line"><span class="lineno">  738</span>                                  &amp;op.promise, &amp;op.future};</div>
<div class="line"><span class="lineno">  739</span>  wgpuQueueOnSubmittedWorkDone(</div>
<div class="line"><span class="lineno">  740</span>      ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>,</div>
<div class="line"><span class="lineno">  741</span>      [](WGPUQueueWorkDoneStatus status, <span class="keywordtype">void</span> *callbackData) {</div>
<div class="line"><span class="lineno">  742</span>        check(status == WGPUQueueWorkDoneStatus_Success, <span class="stringliteral">&quot;Queue work done&quot;</span>,</div>
<div class="line"><span class="lineno">  743</span>              __FILE__, __LINE__);</div>
<div class="line"><span class="lineno">  744</span>        const auto *data = static_cast&lt;CallbackDataDyn *&gt;(callbackData);</div>
<div class="line"><span class="lineno">  745</span>        wgpuBufferMapAsync(</div>
<div class="line"><span class="lineno">  746</span>            data-&gt;buffer, WGPUMapMode_Read, 0, data-&gt;bufferSize,</div>
<div class="line"><span class="lineno">  747</span>            [](WGPUBufferMapAsyncStatus status, void *captureData) {</div>
<div class="line"><span class="lineno">  748</span>              const auto *data = static_cast&lt;CallbackDataDyn *&gt;(captureData);</div>
<div class="line"><span class="lineno">  749</span>              check(status == WGPUBufferMapAsyncStatus_Success,</div>
<div class="line"><span class="lineno">  750</span>                    <span class="stringliteral">&quot;Map readbackBuffer&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"><span class="lineno">  751</span>              const void *mappedData = wgpuBufferGetConstMappedRange(</div>
<div class="line"><span class="lineno">  752</span>                  data-&gt;buffer, <span class="comment">/*offset=*/</span>0, data-&gt;bufferSize);</div>
<div class="line"><span class="lineno">  753</span>              check(mappedData, <span class="stringliteral">&quot;Get mapped range&quot;</span>, __FILE__, __LINE__);</div>
<div class="line"><span class="lineno">  754</span>              memcpy(data-&gt;output, mappedData, data-&gt;bufferSize);</div>
<div class="line"><span class="lineno">  755</span>              wgpuBufferUnmap(data-&gt;buffer);</div>
<div class="line"><span class="lineno">  756</span>              data-&gt;promise-&gt;set_value();</div>
<div class="line"><span class="lineno">  757</span>            },</div>
<div class="line"><span class="lineno">  758</span>            callbackData);</div>
<div class="line"><span class="lineno">  759</span>      },</div>
<div class="line"><span class="lineno">  760</span>      &amp;callbackData);</div>
<div class="line"><span class="lineno">  761</span>  <a class="code hl_function" href="#ae2d750e74781cee97de3145d9949b777">wait</a>(ctx, op.future);</div>
<div class="line"><span class="lineno">  762</span>}</div>
<div class="ttc" id="anamespacegpu_html_ae2d750e74781cee97de3145d9949b777"><div class="ttname"><a href="#ae2d750e74781cee97de3145d9949b777">gpu::wait</a></div><div class="ttdeci">void wait(Context &amp;ctx, std::future&lt; void &gt; &amp;future)</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00689">gpu.h:689</a></div></div>
<div class="ttc" id="astructgpu_1_1_callback_data_dyn_html"><div class="ttname"><a href="structgpu_1_1_callback_data_dyn.html">gpu::CallbackDataDyn</a></div><div class="ttdoc">Used for on-done callback data for asynchronous operations sduch as kernel launching.</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00332">gpu.h:332</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a398921cf034bedbf09842257269b3d19" name="a398921cf034bedbf09842257269b3d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398921cf034bedbf09842257269b3d19">&#9670;&#160;</a></span>toCPU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gpu::toCPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; float, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload of the toCPU function to copy data from a GPU buffer to CPU memory for an array of floats instead of a pointer to a float buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance representing the GPU buffer to copy from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td><a class="el" href="structgpu_1_1_array.html" title="Represents a buffer of values on the GPU.">Array</a> of floats to copy the data to</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#a8512ee079905e5861ab90064caefc299">toCPU</a>(ctx, tensor, data);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00776">776</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  776</span>                                                                   {</div>
<div class="line"><span class="lineno">  777</span>  <a class="code hl_function" href="#a8512ee079905e5861ab90064caefc299">toCPU</a>(ctx, tensor, data.data(), <span class="keyword">sizeof</span>(data));</div>
<div class="line"><span class="lineno">  778</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2fae6ec686b7fdf2f82ab515ea67b167" name="a2fae6ec686b7fdf2f82ab515ea67b167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fae6ec686b7fdf2f82ab515ea67b167">&#9670;&#160;</a></span>toGPU() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::toGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_tensor.html">Tensor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tensor</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of the toGPU function to copy data from CPU memory to a GPU taking a <a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance instead of a WGPUBuffer instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the CPU memory to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tensor</td><td><a class="el" href="structgpu_1_1_tensor.html" title="Represents a tensor on the GPU, which is a buffer of values with a shape.">Tensor</a> instance representing the GPU buffer to copy to</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#acb3f60f1a4282808c882b205d05c44ab">toGPU</a>(ctx, data, tensor);</div>
<div class="ttc" id="anamespacegpu_html_acb3f60f1a4282808c882b205d05c44ab"><div class="ttname"><a href="#acb3f60f1a4282808c882b205d05c44ab">gpu::toGPU</a></div><div class="ttdeci">void toGPU(Context &amp;ctx, const void *data, WGPUBuffer buffer, size_t size)</div><div class="ttdoc">Copies data from CPU memory to a GPU buffer. The toGPU overloads are effectively a convenience wrappe...</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00794">gpu.h:794</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00810">810</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  810</span>                                                                   {</div>
<div class="line"><span class="lineno">  811</span>  wgpuQueueWriteBuffer(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>, tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#ac4df84a36b0d7c8f1dbf54adfe999ad8">buffer</a>, 0, data,</div>
<div class="line"><span class="lineno">  812</span>                       tensor.<a class="code hl_variable" href="structgpu_1_1_tensor.html#abc63dd485f74fa62eb8ee63f1b5ec767">data</a>.<a class="code hl_variable" href="structgpu_1_1_array.html#a4dbb66b98ca78d85a755e11b3607c3e2">size</a>);</div>
<div class="line"><span class="lineno">  813</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acb3f60f1a4282808c882b205d05c44ab" name="acb3f60f1a4282808c882b205d05c44ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3f60f1a4282808c882b205d05c44ab">&#9670;&#160;</a></span>toGPU() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::toGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WGPUBuffer</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies data from CPU memory to a GPU buffer. The toGPU overloads are effectively a convenience wrapper around the WebGPU API call wgpuQueueWriteBuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td><a class="el" href="structgpu_1_1_context.html" title="Represents a GPU context, aggregates WebGPU API handles to interact with the GPU including the instan...">Context</a> instance to manage the operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the CPU memory to copy from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>WGPUBuffer instance representing the GPU buffer to copy to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the data buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a class="code hl_function" href="#acb3f60f1a4282808c882b205d05c44ab">toGPU</a>(ctx, data, buffer, <a class="code hl_function" href="#ad0a150a30d8cb17db98e18ad6df0dcea">size</a>);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00794">794</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  795</span>                               {</div>
<div class="line"><span class="lineno">  796</span>  wgpuQueueWriteBuffer(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>, buffer, 0, data, size);</div>
<div class="line"><span class="lineno">  797</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0273ad1b353bd0cbde0460c87d929705" name="a0273ad1b353bd0cbde0460c87d929705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0273ad1b353bd0cbde0460c87d929705">&#9670;&#160;</a></span>toGPU() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Params &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::toGPU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Params &amp;</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_kernel.html">Kernel</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00817">817</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  817</span>                                                            {</div>
<div class="line"><span class="lineno">  818</span>  <span class="comment">// TODO(avh): Maintain params metadata in Kernel and check for consistency.</span></div>
<div class="line"><span class="lineno">  819</span>  <span class="comment">// If a kernel does not have parameters this will quietly overwrite</span></div>
<div class="line"><span class="lineno">  820</span>  <span class="comment">// the last buffer in the bind group with the parameters buffer.</span></div>
<div class="line"><span class="lineno">  821</span>  <span class="keywordflow">if</span> (op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a552ac93214b23de9d252e0823adcd7ff">numBindings</a> &gt; 0) {</div>
<div class="line"><span class="lineno">  822</span>    wgpuQueueWriteBuffer(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a6e289f57ee9bfa539477ecf18726242e">queue</a>,</div>
<div class="line"><span class="lineno">  823</span>                         op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#aecc74359af917ca7f6937beda8b21a24">buffers</a>[op.<a class="code hl_variable" href="structgpu_1_1_kernel.html#a552ac93214b23de9d252e0823adcd7ff">numBindings</a> - 1], 0,</div>
<div class="line"><span class="lineno">  824</span>                         <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(&amp;params), <span class="keyword">sizeof</span>(params));</div>
<div class="line"><span class="lineno">  825</span>  }</div>
<div class="line"><span class="lineno">  826</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad9d124faa9f793d96e4e0e5531934ac9" name="ad9d124faa9f793d96e4e0e5531934ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9d124faa9f793d96e4e0e5531934ac9">&#9670;&#160;</a></span>toString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gpu::toString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpu_1_1_shape.html">Shape</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shape</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <a class="el" href="structgpu_1_1_shape.html" title="Represents the shape of a tensor.">Shape</a> to string. The string formatting is meant to be slotted into WGSL code (hence no additional parentheses or brackets). </p>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00201">201</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  201</span>                                              {</div>
<div class="line"><span class="lineno">  202</span>  std::string str;</div>
<div class="line"><span class="lineno">  203</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; shape.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a>; i++) {</div>
<div class="line"><span class="lineno">  204</span>    str += std::to_string(shape.<a class="code hl_variable" href="structgpu_1_1_shape.html#a3f473a293f06b3b0b87e45f2ce707626">data</a>[i]);</div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">if</span> (i &lt; shape.<a class="code hl_variable" href="structgpu_1_1_shape.html#a0a0e6afec8c276bd46d6b9a8f9a2244e">rank</a> - 1) {</div>
<div class="line"><span class="lineno">  206</span>      str += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line"><span class="lineno">  207</span>    }</div>
<div class="line"><span class="lineno">  208</span>  }</div>
<div class="line"><span class="lineno">  209</span>  <span class="keywordflow">return</span> str;</div>
<div class="line"><span class="lineno">  210</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a735cb8bbb44ccc41d38889342d5825ea" name="a735cb8bbb44ccc41d38889342d5825ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735cb8bbb44ccc41d38889342d5825ea">&#9670;&#160;</a></span>toString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gpu::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a7641c2218622a47af47216dc8b053fa9">NumType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts NumType to string. </p>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00187">187</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  187</span>                                        {</div>
<div class="line"><span class="lineno">  188</span>  <span class="keywordflow">switch</span> (type) {</div>
<div class="line"><span class="lineno">  189</span>  <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="#a7641c2218622a47af47216dc8b053fa9aa9a0aab3519487443b9015674c54b3fe">kf32</a>:</div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">return</span> <span class="stringliteral">&quot;f32&quot;</span>;</div>
<div class="line"><span class="lineno">  191</span>  <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  192</span>    <a class="code hl_function" href="#a508fff3f15882a37b1c0bd0341296176">LOG</a>(kDefLog, kError, <span class="stringliteral">&quot;Invalid NumType in string conversion.&quot;</span>);</div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line"><span class="lineno">  194</span>  }</div>
<div class="line"><span class="lineno">  195</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5bec633630490d58392b1e4510dc5ef8" name="a5bec633630490d58392b1e4510dc5ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bec633630490d58392b1e4510dc5ef8">&#9670;&#160;</a></span>toString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gpu::toString </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts size_t to string. Wraps std::to_string for consistency, instead of having to remember to switch between std::to_string and toString depending on the type. </p>

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00217">217</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  217</span>{ <span class="keywordflow">return</span> std::to_string(value); }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a841ef6a84098e4202bfd50e08e33164c" name="a841ef6a84098e4202bfd50e08e33164c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841ef6a84098e4202bfd50e08e33164c">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::transpose </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>M</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input matrix. </td></tr>
    <tr><td class="paramname">output</td><td>The output matrix. </td></tr>
    <tr><td class="paramname">M</td><td>The number of rows in the input matrix. </td></tr>
    <tr><td class="paramname">N</td><td>The number of columns in the input matrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00250">250</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  250</span>                                                                       {</div>
<div class="line"><span class="lineno">  251</span>  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; M; i++) {</div>
<div class="line"><span class="lineno">  252</span>    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = 0; j &lt; N; j++) {</div>
<div class="line"><span class="lineno">  253</span>      output[j * M + i] = input[i * N + j];</div>
<div class="line"><span class="lineno">  254</span>    }</div>
<div class="line"><span class="lineno">  255</span>  }</div>
<div class="line"><span class="lineno">  256</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae2d750e74781cee97de3145d9949b777" name="ae2d750e74781cee97de3145d9949b777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d750e74781cee97de3145d9949b777">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gpu::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpu_1_1_context.html">Context</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::future&lt; void &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>future</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00689">689</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  689</span>                                                        {</div>
<div class="line"><span class="lineno">  690</span>  <span class="keywordflow">while</span> (future.wait_for(std::chrono::seconds(0)) !=</div>
<div class="line"><span class="lineno">  691</span>         std::future_status::ready) {</div>
<div class="line"><span class="lineno">  692</span>    wgpuInstanceProcessEvents(ctx.<a class="code hl_variable" href="structgpu_1_1_context.html#a9a7416f53b4e2a97af33929d7c50969c">instance</a>);</div>
<div class="line"><span class="lineno">  693</span>  }</div>
<div class="line"><span class="lineno">  694</span>}</div>
<div class="ttc" id="astructgpu_1_1_context_html_a9a7416f53b4e2a97af33929d7c50969c"><div class="ttname"><a href="structgpu_1_1_context.html#a9a7416f53b4e2a97af33929d7c50969c">gpu::Context::instance</a></div><div class="ttdeci">WGPUInstance instance</div><div class="ttdef"><b>Definition</b> <a href="gpu_8h_source.html#l00391">gpu.h:391</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9ff18d8b3b09f727e44a58cb443c2ddb" name="a9ff18d8b3b09f727e44a58cb443c2ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff18d8b3b09f727e44a58cb443c2ddb">&#9670;&#160;</a></span>IsNoParam</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gpu::IsNoParam = std::is_same_v&lt;T, <a class="el" href="structgpu_1_1_no_param.html">NoParam</a>&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00862">862</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>

</div>
</div>
<a id="aa260b4aa723e3754e338952a00a00fa5" name="aa260b4aa723e3754e338952a00a00fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa260b4aa723e3754e338952a00a00fa5">&#9670;&#160;</a></span>kDebug</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gpu::kDebug = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="gpu_8h_source.html#l00023">23</a> of file <a class="el" href="gpu_8h_source.html">gpu.h</a>.</p>

</div>
</div>
<a id="a0188200bb20637971454432ffdb2e3ab" name="a0188200bb20637971454432ffdb2e3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0188200bb20637971454432ffdb2e3ab">&#9670;&#160;</a></span>kDefLog</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgpu_1_1_logger.html">Logger</a> gpu::kDefLog = {stdout, &quot;&quot;, <a class="el" href="#a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27">kInfo</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default logger for logging messages to stdout at the info level. Output stream and logging level for the default logger can be globally changed on a per-program basis. </p>

<p class="definition">Definition at line <a class="el" href="logging_8h_source.html#l00064">64</a> of file <a class="el" href="logging_8h_source.html">logging.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   64</span>{stdout, <span class="stringliteral">&quot;&quot;</span>, <a class="code hl_enumvalue" href="#a8387bde500e78abd34b817796e0ab156ae0c75f8284ef21f84d64259522a74b27">kInfo</a>};</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae1d3f2326d04b410a85cbd7b3ac2b876" name="ae1d3f2326d04b410a85cbd7b3ac2b876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d3f2326d04b410a85cbd7b3ac2b876">&#9670;&#160;</a></span>kLevelStr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* gpu::kLevelStr[] = {&quot;error&quot;, &quot;warn&quot;, &quot;info&quot;, &quot;trace&quot;}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="logging_8h_source.html#l00011">11</a> of file <a class="el" href="logging_8h_source.html">logging.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   11</span>{<span class="stringliteral">&quot;error&quot;</span>, <span class="stringliteral">&quot;warn&quot;</span>, <span class="stringliteral">&quot;info&quot;</span>, <span class="stringliteral">&quot;trace&quot;</span>};</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba79867fea95e4073373d7618094a9cd" name="aba79867fea95e4073373d7618094a9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba79867fea95e4073373d7618094a9cd">&#9670;&#160;</a></span>kShowMaxCols</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gpu::kShowMaxCols = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00027">27</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>

</div>
</div>
<a id="add001dc6cf01bdd72293694791d5d1bc" name="add001dc6cf01bdd72293694791d5d1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add001dc6cf01bdd72293694791d5d1bc">&#9670;&#160;</a></span>kShowMaxRows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gpu::kShowMaxRows = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="array__utils_8h_source.html#l00026">26</a> of file <a class="el" href="array__utils_8h_source.html">array_utils.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegpu.html">gpu</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
